动态规划入门19
分类：算法与数据结构 

 例题18

回文词

                     (palin.pas/c/cpp)

来源：IOI 2000

【问题描述】

   回文词是一种对称的字符串――也就是说，一个回文词，从左到右读和从右到左读得到的结果是一样的。任意给定一个字符串，通过插入若干字符，都可以变成一个回文词。你的任务是写一个程序，求出将给定字符串变成回文词所需插入的最少字符数。
　  比如字符串“Ab3bd”，在插入两个字符后可以变成一个回文词（“dAb3bAd”或“Adb3bdA”）。然而，插入两个以下的字符无法使它变成一个回文词。

【输入文件】

  第一行包含一个整数N，表示给定字符串的长度，3<=N<=5000
　第二行是一个长度为N的字符串，字符串由大小写字母和数字构成。

【输出文件】

   一个整数，表示需要插入的最少字符数。

 

【输入样例】

  5

Ab3bd

【输出样例】

2

【问题分析】

所谓回文词（正着读和反着读一样），其实就是从中间断开把后面翻转后与前面部分一样（注意奇数和偶数有区别）。例：

回文词：AB3BA

断开：AB     BA     （奇数个时去掉中间字符）

翻转：AB     AB

 这个题目要求出最少填几个数可以使一个字符串变成回文词，也就是说从任意点截断，再翻转后面部分后。两个序列有相同的部分不用添字符，不一样的部分添上字符就可以了。例：

回文词：Ab3bd

截断：Ab      bd

翻转：Ab      db

b在两个序列里都有，在第二个里添A在第一个里添d就可以了：

Adb       Adb

这样添两个就可以了，

显然从别的地方截断添的个数要比这样多。

这样就把原问题抽象成求最长公共子序列问题了。枚举截断点，把原串截断，翻转。求最长公共子序列。答案就是len-（ans*2） len是翻转后两个序列的长度和。Ans 是最长公共子序列的长度。

其实这样求解很麻烦，做了好多重复的工作。仔细想想既然在最后求解ans还要乘2那么在先前计算时直接把原串翻转作为第二个序列和第一个序列求最长公共子序列就可以了。这样最后求解就不用乘2了，也不用枚举截断点了例：

原串：Ab3bd

翻转：db3bA

最长公共子序列b3b

添加2个字符

怎么理解这个优化呢？

其实翻转了序列后字符的先后顺序就变了，求解最长公共子序列中得到的解，是唯一的，也就是说这个序列的顺序是唯一的，如果在翻转后的序列和原串能得到相同的序列，那么这个序列在两个串中字符间的顺序是横定的，着就满足了回文词的定义（正着读和反着读一样）。所以这个优化是正确的。

注意：

    这个问题的数据规模很大，空间复杂度交高（O（N2））所以要用到滚动数组，如果不知道什么是滚动数组就该往后翻页，应为我在后面的动态规划的优化里会说到。

【源代码1】

program P1327;

const

 maxn=5002;

var

 a,b:ansistring;

 opt:array[0..1,0..maxn] of longint;

 n,ans:longint;

function max(x,y:longint):longint;

 begin

  if x>y then exit(x);

  max:=y;

 end;

procedure main;

 var

  i,x,j,k0,k1:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  readln(n);

  readln(a);

  b:='';

  for i:=n downto 1 do

   b:=b+a[i];

  k0:=0;

  k1:=1;

  for i:=1 to n do

   begin

    fillchar(opt[k1],sizeof(opt[k1]),0);

    for j:=1 to n do

     begin

      opt[k1,j]:=max(opt[k0,j],opt[k1,j-1]);

      if a[i]=b[j] then

       opt[k1,j]:=max(opt[k1,j],opt[k0,j-1]+1);

     end;

    x:=k0;

    k0:=k1;

    k1:=x;

   end;

  writeln(n-opt[k0,n]);

 end;

begin

 main;

end.

用这个方法AC了就该很高兴了，但不要停止思考的步伐，还有别的方法么？

从原问题出发，找这个问题的子问题。和上面说的最长公共子序列问题一样，设计序列的问题我们一般要考虑它的子序列，也就是更短的序列。

这样就回到了我第一节说的边界条件法了。

显然单独的字符就是边界了，而且单独的字符就是回文词，添加0个字符就可以了。

如果是两个字符组成的序列怎么办呢？

只要看他们是否相同就可以了，如果相同那就是回文词了，添加0个字符，如果不相同就在它的左边或右边添一个字符，让另外一个当对称轴。

如果是3个字符呢？

我们用S存这个序列，如果S[1]=S[3]那么它就是回文词了,

如果S[1]<>S[3]那么就在前面添S[3]或后面添S[1]

剩下的就要考虑S[1]S[2]和S[2]S[3]这两个序列了。

通过前面的分析我们很容易想到这样的算法：

对于一个序列S只要看它的左右端的字符是否相同，如果相同那么就看除掉两端字符的新串要添的字符个数了；如果不同，就在它左面添上右断的字符然后考虑去掉新序列两端的字符后的串要添的字符。或者在右面添上左端的字符，在考虑去掉添了字符后新串左右两端字符得到的新串要添的字符。

设计一个二维状态opt[L,i]表示长度是L+1，起点是i的序列变成回文词要添的字符的个数。阶段就是字符的长度，决策要分类，即S[i] 和S[i+L]是否相等。

状态转移方程:

min(opt[L-1,i]+1, opt[L-1,i+1]+1)           (s[i]<>s[i+L])

opt[L,i]=

             min(opt[L-1,i]+1, opt[L-1,i+1]+1,opt[L-2,i+1])  (s[i]=s[i+L])

复杂度：

空间复杂度=状态数O（N2）

时间复杂度=状态数O（N2）* 转移代价O（1）=O（N2）

由于空间复杂度较高，仍然要用滚动数组。

【源代码2】

program P1327;

const

 maxn=5002;

var

 a:array[0..maxn] of char;

 opt:array[0..2,0..maxn] of longint;

 n,ans:longint;

function min(x,y:longint):longint;

 begin

  min:=y;

  if x<y then min:=x;

 end;

procedure main;

 var

  i,L,j,k0,k1,k2:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  readln(n);

  for i:=1 to n do

   read(a[i]);

  k0:=0;

  k1:=1;

  k2:=2;

  for L:=1 to n-1 do

   begin

    for i:=1 to n-L do

     begin

      opt[k2,i]:=min(opt[k1,i],opt[k1,i+1])+1;

      if a[i]=a[i+L] then

       opt[k2,i]:=min(opt[k2,i],opt[k0,i+1]);

     end;

    j:=k0;

    k0:=k1;

    k1:=k2;

    k2:=j;

   end;

  writeln(opt[k1,1]);

 end;

begin

 main;

end.