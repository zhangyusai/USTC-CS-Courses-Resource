<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0068)http://www.ynjy.cn/Article/200901/Article_20090114141359_14096.shtml -->
<HTML><HEAD><TITLE>（第一篇）动态规划 Dynamic Programming</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<STYLE type=text/css>.style1 {
	COLOR: #0099cc
}
</STYLE>
<LINK href="（第一篇）动态规划 Dynamic Programming.files/DefaultSkin.css" type=text/css 
rel=stylesheet>
<SCRIPT language=JavaScript src="（第一篇）动态规划 Dynamic Programming.files/menu.js" 
type=text/JavaScript></SCRIPT>

<SCRIPT language=JavaScript1.2 
src="（第一篇）动态规划 Dynamic Programming.files/stm31.js" 
type=text/javascript></SCRIPT>

<SCRIPT language=JavaScript type=text/JavaScript>
//改变图片大小
function resizepic(thispic)
{
if(thispic.width>700){thispic.height=thispic.height*700/thispic.width;thispic.width=700;} 
}
//无级缩放图片大小
function bbimg(o)
{
  var zoom=parseInt(o.style.zoom, 10)||100;
  zoom+=event.wheelDelta/12;
  if (zoom>0) o.style.zoom=zoom+'%';
  return false;
}
//双击鼠标滚动屏幕的代码
var currentpos,timer;
function initialize()
{
timer=setInterval ("scrollwindow ()",30);
}
function sc()
{
clearInterval(timer);
}
function scrollwindow()
{
currentpos=document.body.scrollTop;
window.scroll(0,++currentpos);
if (currentpos !=document.body.scrollTop)
sc();
}
document.onmousedown=sc
document.ondblclick=initialize

//更改字体大小
var status0='';
var curfontsize=10;
var curlineheight=18;
function fontZoomA(){
  if(curfontsize>8){
    document.getElementById('fontzoom').style.fontSize=(--curfontsize)+'pt';
	document.getElementById('fontzoom').style.lineHeight=(--curlineheight)+'pt';
  }
}
function fontZoomB(){
  if(curfontsize<64){
    document.getElementById('fontzoom').style.fontSize=(++curfontsize)+'pt';
	document.getElementById('fontzoom').style.lineHeight=(++curlineheight)+'pt';
  }
}
</SCRIPT>

<META content="MSHTML 6.00.2900.5659" name=GENERATOR></HEAD>
<BODY>
<DIV id=menuDiv 
style="Z-INDEX: 1000; VISIBILITY: hidden; WIDTH: 1px; POSITION: absolute; HEIGHT: 1px; BACKGROUND-COLOR: #9cc5f8"></DIV>
<TABLE class=top_tdbgall style="WORD-BREAK: break-all" cellSpacing=0 
cellPadding=0 width=760 align=center border=0><!--顶部空距代码-->
  <TBODY>
  <TR>
    <TD class=top_top><A title=云南教育门户 href="http://www.ynjy.cn/"><IMG 
      height=160 src="（第一篇）动态规划 Dynamic Programming.files/logo2.jpg" width=746 
      border=0></A></TD></TR><!--频道显示代码-->
  <TR>
    <TD class=top_Channel align=right></TD></TR></TBODY></TABLE><!--导航代码开始-->
<TABLE class=top_Path style="WORD-BREAK: break-all" cellSpacing=0 cellPadding=0 
width=760 align=center border=0>
  <TBODY>
  <TR>
    <TD align=middle width="5%"><IMG height=11 
      src="（第一篇）动态规划 Dynamic Programming.files/arrow3.gif" width=29></TD>
    <TD width="73%">您现在的位置：&nbsp;<A class=LinkPath 
      href="http://www.ynjy.cn/">云南教育门户</A>&nbsp;&gt;&gt;&nbsp;<A class=LinkPath 
      href="http://www.ynjy.cn/Article/Index.shtml">文章中心</A>&nbsp;&gt;&gt;&nbsp;<A 
      class=LinkPath 
      href="http://www.ynjy.cn/Article/List/List_14.shtml">云南省教研网</A>&nbsp;&gt;&gt;&nbsp;<A 
      class=LinkPath 
      href="http://www.ynjy.cn/Article/List/List_196.shtml">奥林匹克竞赛</A>&nbsp;&gt;&gt;&nbsp;<A 
      class=LinkPath 
      href="http://www.ynjy.cn/Article/List/List_202.shtml">学习指导</A>&nbsp;&gt;&gt;&nbsp;正文</TD>
    <TD align=right width="22%">　</TD></TR></TBODY></TABLE><!--导航代码结束--><!-- ********网页顶部代码结束******** --><!-- ********网页中部代码开始******** --><!--文章显示代码开始-->
<TABLE class=center_tdbgall 
style="WIDTH: 760px; WORD-BREAK: break-all; HEIGHT: 525px" cellSpacing=0 
cellPadding=0 width=760 align=center border=0>
  <TBODY>
  <TR>
    <TD colSpan=2>
      <TABLE class=main_title_760 style="WORD-BREAK: break-all" cellSpacing=0 
      cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD vAlign=center width="3%"><IMG 
            src="（第一篇）动态规划 Dynamic Programming.files/arrow.gif" 
          align=absMiddle></TD>
          <TD width="66%"><STRONG><SPAN 
            class=S_headline2>[组图]</SPAN>（第一篇）动态规划&nbsp;Dynamic&nbsp;Programming</STRONG></TD>
          <TD 
            width="18%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT 
            color=#009999>★★★</FONT></TD>
          <TD align=right width="13%">【字体：<A 
            href="javascript:fontZoomA();"><FONT color=#ffffff>小</FONT></A> <A 
            href="javascript:fontZoomB();"><FONT 
        color=#ffffff>大</FONT></A>】</TD></TR></TBODY></TABLE></TD></TR>
  <TR vAlign=center align=middle>
    <TD class=main_ArticleTitle style="WORD-BREAK: break-all" colSpan=2 
    height=50>（第一篇）动态规划 Dynamic Programming</TD></TR>
  <TR vAlign=center align=middle>
    <TD class=main_ArticleSubheading style="WORD-BREAK: break-all" 
    colSpan=2></TD></TR>
  <TR align=middle>
    <TD class=Article_tdbgall 
      colSpan=2>作者：佚名&nbsp;&nbsp;&nbsp;&nbsp;文章来源：本站原创&nbsp;&nbsp;&nbsp;&nbsp;点击数：
      <SCRIPT language=javascript 
      src="（第一篇）动态规划 Dynamic Programming.files/GetHits.htm"></SCRIPT>
      &nbsp;&nbsp;&nbsp;&nbsp;更新时间：2009-1-14</TD></TR>
  <TR>
    <TD class=main_tdbg_760 id=fontzoom style="WORD-BREAK: break-all" vAlign=top 
    colSpan=2 height=300>
      <TABLE cellSpacing=0 cellPadding=10 align=left border=0>
        <TBODY>
        <TR>
          <TD><!--插入广告JS代码--></TD></TR></TBODY></TABLE>
      <DIV align=center><FONT size=4><B>动态规划</B><B>&nbsp; Dynamic 
      Programming</B></FONT></DIV>
      <DIV><FONT size=4><B>提要</B><B>&nbsp;&nbsp;&nbsp; 
      </B>本文介绍了动态规划的基本思想和基本步骤，通过实例研究了利用动态规划设计算法的具体途径，讨论了动态规划的一些实现技巧，并将动态规划和其他一些算法作了比较，最后还简单介绍了动态规划的数学理论基础和当前最新的研究成果。</FONT></DIV>
      <DIV align=center><B><FONT size=4>目录</FONT></B></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm"><FONT 
      face=宋体 size=4>引言</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter1.htm"><FONT 
      face=宋体 size=4>动态规划的基本概念</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter2.htm"><FONT 
      face=宋体 size=4>动态规划的基本定理和基本方程</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter3.htm"><FONT 
      face=宋体 size=4>动态规划的适用条件</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter4.htm"><FONT 
      face=宋体 size=4>动态规划的基本思想</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter5.htm"><FONT 
      face=宋体 size=4>动态规划的基本步骤</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter6.htm"><FONT 
      face=宋体 size=4>动态规划的实例分析</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter7.htm"><FONT 
      face=宋体 size=4>动态规划的技巧</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter8.htm"><FONT 
      face=宋体 size=4>动态规划实现中的问题</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter9.htm"><FONT 
      face=宋体 size=4>动态规划与其他算法的比较 </FONT></A></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter10.htm"><FONT 
      face=宋体 size=4>动态规划的理论基础</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter11.htm"><FONT 
      face=宋体 size=4>其他资料</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><B><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435192.htm" 
      border=0></FONT></B></DIV>
      <DIV>
      <DIV><CODE><FONT face=新宋体 size=4>function 
      MinDistance(v):integer;</FONT></CODE></DIV>
      <DIV><CODE><FONT face=新宋体 size=4>begin</FONT></CODE></DIV>
      <DIV><CODE><FONT face=新宋体 size=4>&nbsp;if v=E then return 
      0</FONT></CODE></DIV>
      <DIV><CODE><FONT face=新宋体 size=4>&nbsp; else</FONT></CODE></DIV>
      <DIV><CODE><FONT face=新宋体 size=4>&nbsp;&nbsp; begin</FONT></CODE></DIV>
      <DIV><CODE><FONT face=新宋体 size=4>&nbsp;&nbsp;&nbsp; 
      min:=maxint;</FONT></CODE></DIV>
      <DIV><FONT size=4><FONT face=新宋体><CODE>&nbsp;&nbsp;&nbsp; for 
      </CODE><CODE>所有没有访问过的节点</CODE><CODE>i do</CODE></FONT></FONT></DIV>
      <DIV><FONT size=4><FONT face=新宋体><CODE>&nbsp;&nbsp;&nbsp; &nbsp;if 
      v</CODE><CODE>和</CODE><CODE>i</CODE><CODE>相邻</CODE><CODE> then 
      </CODE></FONT></FONT></DIV>
      <DIV><CODE><FONT face=新宋体 size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></CODE></DIV>
      <DIV><FONT size=4><FONT 
      face=新宋体><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      </CODE><CODE>标记</CODE><CODE>i</CODE><CODE>访问过了</CODE><CODE>;</CODE></FONT></FONT></DIV>
      <DIV><FONT size=4><FONT 
      face=新宋体><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      t:=v</CODE><CODE>到</CODE><CODE>i</CODE><CODE>的距离</CODE><CODE>+MinDistance(i);</CODE></FONT></FONT></DIV>
      <DIV><FONT size=4><FONT 
      face=新宋体><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      </CODE><CODE>标记</CODE><CODE>i</CODE><CODE>未访问过</CODE><CODE>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      </CODE></FONT></FONT></DIV>
      <DIV><CODE><FONT size=4><FONT 
      face=新宋体>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if t<MIN 
      min="t;</CODE" then></FONT></FONT></DIV>
      <DIV><CODE><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;&nbsp; 
      </FONT></CODE></DIV>
      <DIV><CODE><FONT size=4>&nbsp;&nbsp; end;</FONT></CODE></DIV>
      <DIV><CODE><FONT size=4>end;</FONT></CODE></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4>开始时标记所有的顶点未访问过，MinDistance(A)就是从A到E的最短距离。</FONT></DIV>
      <DIV><FONT 
      size=4>这个程序的效率如何呢？我们可以看到，每次除了已经访问过的城市外，其他城市都要访问，所以时间复杂度为O(n!)，这是一个“指数级”的算法，那么，还有没有更好的算法呢？</FONT></DIV>
      <DIV><FONT 
      size=4>首先，我们来观察一下这个算法。在求从B1到E的最短距离的时候，先求出从C2到E的最短距离；而在求从B2到E的最短距离的时候，又求了一遍从C2到E的最短距离。也就是说，从C2到E的最短距离我们求了两遍。同样可以发现，在求从C1、C2到E的最短距离的过程中，从D1到E的最短距离也被求了两遍。而在整个程序中，从D1到E的最短距离被求了四遍。如果在求解的过程中，同时将求得的最短距离"记录在案"，随时调用，就可以避免这种情况。于是，可以改进该算法，将每次求出的从v到E的最短距离记录下来，在算法中递归地求MinDistance(v)时先检查以前是否已经求过了MinDistance(v)，如果求过了则不用重新求一遍，只要查找以前的记录就可以了。这样，由于所有的点有n个，因此不同的状态数目有n个，该算法的数量级为O(n)。</FONT></DIV>
      <DIV><FONT size=4>更进一步，可以将这种递归改为递推，这样可以减少递归调用的开销。</FONT></DIV>
      <DIV><FONT size=4>请看</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#img1#img1"><FONT 
      face=宋体 size=4>图1</FONT></A><FONT 
      size=4>，可以发现，A只和B<SUB>i</SUB>相邻，B<SUB>i</SUB>只和C<SUB>i</SUB>相邻,...，依此类推。这样，我们可以将原问题的解决过程划分为4个阶段，设</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435849.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT 
      size=4>显然可以递推地求出F<SUB>1</SUB>(A)，也就是从A到E的最短距离。这种算法的复杂度为O(n)，因为所有的状态总数（节点总数）为n，对每个状态都只要遍历一次，而且程序很简洁。</FONT></DIV>
      <DIV><FONT size=4>具体算法如下：</FONT></DIV>
      <DIV><FONT size=4>procedure DynamicProgramming;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp; F5[E]:=0;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; for i:=4 downto 1 do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp; for each u ∈Sk do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      Fk[u]:=无穷大;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for each 
      v∈Sk+1∩δ(u) do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 
      Fk[u]&gt;w(u,v)+Fk+1[v] then Fk[u]:=w(u,v)+Fk+1[v];</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp; end;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; 输出F1[A]; </FONT></DIV>
      <DIV><FONT size=4>&nbsp;end;</FONT></DIV>
      <DIV><FONT size=4>这种高效算法，就是<DFN>动态规划算法</DFN>。</FONT></DIV>
      <DIV><FONT size=4><B>二、动态规划的基本概念</B><B></B></FONT></DIV>
      <DIV><FONT size=4><B>1</B><B>、动态规划的发展及研究内容</B><B></B></FONT></DIV>
      <DIV><FONT size=4><DFN>动态规划</DFN><DFN>(dynamic 
      programming)</DFN>是运筹学的一个分支，是求解<DFN>决策过程</DFN><DFN>(decision 
      process)</DFN>最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究<DFN>多阶段决策过程</DFN><DFN>(multistep 
      decision process)</DFN>的优化问题时，提出了著名的<DFN>最优化原理</DFN><DFN>(principle of 
      optimality)</DFN>，把多阶段过程转化为一系列单阶段问题，逐个求解，创立了解决这类过程优化问题的新方法――动态规划。1957年出版了他的名著<CITE>Dynamic 
      Programming</CITE>，这是该领域的第一本著作。</FONT></DIV>
      <DIV><FONT 
      size=4>动态规划问世以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。</FONT></DIV>
      <DIV><FONT 
      size=4>虽然动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。</FONT></DIV>
      <DIV><FONT size=4><DFN>2</DFN><DFN>、多阶段决策过程与</DFN>多阶段决策问题</FONT></DIV>
      <DIV><FONT 
      size=4><DFN>多阶段决策过程</DFN>，是指这样的一类特殊的活动过程，问题可以按时间顺序分解成若干相互联系的阶段，在每一个阶段都要做出决策，全部过程的决策是一个决策序列。要使整个活动的总体效果达到最优的问题，称为<DFN>多阶段决策问题</DFN>。</FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#example1"><FONT 
      face=宋体 size=4>例1</FONT></A><FONT 
      size=4>是一个多阶段决策问题的例子，下面是另一个多阶段决策问题的例子：</FONT></DIV>
      <DIV><FONT size=4><B>[</B><B>例</B><B>2]</B></FONT><A 
      name=example2></A><FONT size=4> 生产计划问题&nbsp;&nbsp;&nbsp; 
      工厂生产某种产品，每单位(千件)的成本为1(千元)，每次开工的固定成本为3(千元)，工厂每季度的最大生产能力为6(千件)。经调查，市场对该产品的需求量第一、二、三、四季度分别为 
      2，3，2，4(千件)。如果工厂在第一、二季度将全年的需求都生产出来，自然可以降低成本(少付固定成本费)，但是对于第三、四季度才能上市的产品需付存储费，每季每千件的存储费为0.5(千元)。还规定年初和年末这种产品均无库存。试制订一个生产计划，即安排每个季度的产量，使一年的总费用(生产成本和存储费)最少。</FONT></DIV>
      <DIV><FONT size=4><B>3</B><B>、决策过程的分类</B><B></B></FONT></DIV>
      <DIV><FONT 
      size=4>根据过程的时间变量是离散的还是连续的，分为<DFN>离散时间决策过程</DFN><DFN>(discrete-time 
      decision process)</DFN>，即多阶段决策过程和<DFN>连续时间决策过程</DFN><DFN>(continuous-time 
      decision 
      process)</DFN>；根据过程的演变是确定的还是随机的，分为<DFN>确定性决策过程</DFN><DFN>(deterministic 
      decision process)</DFN>和<DFN>随机性决策过程</DFN><DFN>(stochastic decision 
      process)</DFN>，其中应用最广的是确定性多阶段决策过程。</FONT></DIV>
      <DIV><FONT size=4><B>4</B><B>、动态规划模型的基本要素</B><B></B></FONT></DIV>
      <DIV><FONT size=4>一个多阶段决策过程最优化问题的动态规划模型通常包含以下要素：</FONT></DIV>
      <DIV><FONT size=4><DFN>1</DFN><DFN>）阶段</DFN></FONT></DIV>
      <DIV><FONT 
      size=4><DFN>阶段</DFN><DFN>(step)</DFN>是对整个过程的自然划分。通常根据时间顺序或空间特征来划分阶段，以便按阶段的次序解优化问题。阶段变量一般用k=1,2,..,n表示。在</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#example1"><FONT 
      face=宋体 size=4>例1</FONT></A><FONT 
      size=4>中由A出发为k=1，由B<SUB>i</SUB>(i=1,2)出发为k=2，依此下去从D<SUB>i</SUB>(i=1,2,3)出发为k=4，共n=4个阶段。在</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter1.htm#example2#example2"><FONT 
      face=宋体 size=4>例2</FONT></A><FONT 
      size=4>中按照第一、二、三、四季度分为k=1,2,3,4，共4个阶段。</FONT></DIV></DIV>
      <DIV>
      <DIV><FONT size=4><DFN>2</DFN><DFN>）状态</DFN></FONT></DIV>
      <DIV><FONT 
      size=4><DFN>状态</DFN><DFN>(state)</DFN>表示每个阶段开始时过程所处的自然状况。它应该能够描述过程的特征并且具有<B>无后向性</B>，即当某阶段的状态给定时，这个阶段以后过程的演变与该阶段以前各阶段的状态无关，即每个状态都是过去历史的一个完整总结。通常还要求状态是直接或间接可以观测的。</FONT></DIV>
      <DIV><FONT size=4>描述状态的变量称<DFN>状态变量</DFN><DFN>(state 
      variable)</DFN>。变量允许取值的范围称<DFN>允许状态集合</DFN><DFN>(set of admissible 
      states)</DFN>。用x<SUB>k</SUB>表示第k阶段的状态变量，它可以是一个数或一个向量。用X<SUB>k</SUB>表示第k阶段的允许状态集合。在</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#example1"><FONT 
      face=宋体 size=4>例1</FONT></A><FONT 
      size=4>中x<SUB>2</SUB>可取B<SUB>1</SUB>，B<SUB>2</SUB>，X<SUB>2</SUB>={B<SUB>1</SUB>,B<SUB>2</SUB>}。</FONT></DIV>
      <DIV><FONT 
      size=4>n个阶段的决策过程有n+1个状态变量，x<SUB>n+1</SUB>表示x<SUB>n</SUB>演变的结果，在</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#example1"><FONT 
      face=宋体 size=4>例1</FONT></A><FONT size=4>中x<SUB>5</SUB>取E。</FONT></DIV>
      <DIV><FONT 
      size=4>根据过程演变的具体情况，状态变量可以是离散的或连续的。为了计算的方便有时将连续变量离散化；为了分析的方便有时又将离散变量视为连续的。</FONT></DIV>
      <DIV><FONT size=4>状态变量简称为<DFN>状态</DFN>。</FONT></DIV>
      <DIV><FONT size=4><DFN>3</DFN><DFN>）决策</DFN></FONT></DIV>
      <DIV><FONT 
      size=4>当一个阶段的状态确定后，可以作出各种选择从而演变到下一阶段的某个状态，这种选择手段称为<DFN>决策</DFN><DFN>(decision)</DFN>，在最优控制问题中也称为<DFN>控制</DFN><DFN>(control)</DFN>。</FONT></DIV>
      <DIV><FONT size=4>描述决策的变量称<DFN>决策变量</DFN><DFN>(decision 
      variable)</DFN>。变量允许取值的范围称<DFN>允许决策集合</DFN><DFN>(set of admissible 
      decisions)</DFN>。用u<SUB>k</SUB>(x<SUB>k</SUB>)表示第k阶段处于状态x<SUB>k</SUB>时的决策变量，它是x<SUB>k</SUB>的函数，用U<SUB>k</SUB>(x<SUB>k</SUB>)表示了x<SUB>k</SUB>的允许决策集合。在</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#example1"><FONT 
      face=宋体 size=4>例1</FONT></A><FONT 
      size=4>中u<SUB>2</SUB>(B<SUB>1</SUB>)可取C<SUB>1</SUB>,C<SUB>2</SUB>,C<SUB>3</SUB>。</FONT></DIV>
      <DIV><FONT size=4>决策变量简称<DFN>决策</DFN>。</FONT></DIV>
      <DIV><FONT size=4><DFN>4</DFN><DFN>）策略</DFN></FONT></DIV>
      <DIV><FONT 
      size=4>决策组成的序列称为<DFN>策略</DFN><DFN>(policy)</DFN>。由初始状态x<SUB>1</SUB>开始的全过程的策略记作p<SUB>1n</SUB>(x<SUB>1</SUB>)，即p<SUB>1n</SUB>(x<SUB>1</SUB>)={u<SUB>1</SUB>(x<SUB>1</SUB>),u<SUB>2</SUB>(x<SUB>2</SUB>),...，u<SUB>n</SUB>(x<SUB>n</SUB>)}。由第k阶段的状态x<SUB>k</SUB>开始到终止状态的后部子过程的策略记作p<SUB>kn</SUB>(x<SUB>k</SUB>)，即p<SUB>kn</SUB>(x<SUB>k</SUB>)={u<SUB>k</SUB>(x<SUB>k</SUB>),u<SUB>k+1</SUB>(x<SUB>k+1</SUB>),...，u<SUB>n</SUB>(x<SUB>n</SUB>)}。类似地，由第k到第j阶段的子过程的策略记作p<SUB>kj</SUB>(x<SUB>k</SUB>)={u<SUB>k</SUB>(x<SUB>k</SUB>),u<SUB>k+1</SUB>(x<SUB>k+1</SUB>),...，u<SUB>j</SUB>(x<SUB>j</SUB>)}。对于每一个阶段k的某一给定的状态x<SUB>k</SUB>，可供选择的策略p<SUB>kj</SUB>(x<SUB>k</SUB>)有一定的范围，称为<DFN>允许策略集合</DFN><DFN>(set 
      of admissible 
      policies)</DFN>，用P<SUB>1n</SUB>(x<SUB>1</SUB>),P<SUB>kn</SUB>(x<SUB>k</SUB>),P<SUB>kj</SUB>(x<SUB>k</SUB>)表示。</FONT></DIV>
      <DIV><FONT size=4><DFN>5</DFN><DFN>）状态转移方程</DFN></FONT></DIV>
      <DIV><FONT 
      size=4>在确定性过程中，一旦某阶段的状态和决策为已知，下阶段的状态便完全确定。用<DFN>状态转移方程</DFN><DFN>(equation 
      of state)</DFN>表示这种演变规律，写作</FONT></DIV>
      <DIV>
      <DIV><FONT size=4></FONT></DIV></DIV></DIV></DIV>
      <DIV><B><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435651.htm" 
      border=0></FONT></B></DIV>
      <DIV>
      <DIV><FONT size=4>在</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#example1"><FONT 
      face=宋体 size=4>例1</FONT></A><FONT 
      size=4>中状态转移方程为：x<SUB>k+1</SUB>=u<SUB>k</SUB>(x<SUB>k</SUB>)</FONT></DIV>
      <DIV><FONT size=4><DFN>6</DFN><DFN>）指标函数和最优值函数</DFN></FONT></DIV>
      <DIV><A name=indexfunc></A><FONT size=4><DFN>指标函数</DFN><DFN>(objective 
      function) 
      </DFN>是衡量过程优劣的数量指标，它是关于策略的数量函数，从阶段k到阶段n的指标函数用V<SUB>kn</SUB>(x<SUB>k</SUB>,p<SUB>kn</SUB>(x<SUB>k</SUB>))表示，k=1,2,...,n。</FONT></DIV>
      <DIV><FONT 
      size=4>能够用动态规划解决的问题的指标函数应具有<DFN>可分离性</DFN>，即V<SUB>kn</SUB>可表为x<SUB>k</SUB>,u<SUB>k</SUB>,V<SUB>k+1 
      n</SUB> 的函数，记为：</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435163.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT 
      size=4>这些形式下第k到第j阶段子过程的指标函数为V<SUB>kj</SUB>(x<SUB>k</SUB>,u<SUB>k</SUB>,x<SUB>k+1</SUB>,...,x<SUB>j+1</SUB>)。可以发现，上述(3)-(5)三个指标函数的形式都满足最优性原理。在</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#example1"><FONT 
      face=宋体 size=4>例1</FONT></A><FONT 
      size=4>中指标函数为(3)的形式，其中v<SUB>j</SUB>(x<SUB>j</SUB>,u<SUB>j</SUB>)是边<X<SUB>j</SUB>,u<SUB>j</SUB>(x<SUB>j</SUB>)&gt;的权（边的长度）,u<SUB>j</SUB>(x<SUB>j</SUB>)表示从x<SUB>j</SUB>出发根据决策u<SUB>j</SUB>(x<SUB>j</SUB>)下一步所到达的节点。</FONT></DIV>
      <DIV><FONT 
      size=4>根据状态转移方程，指标函数V<SUB>kn</SUB>还可以表示为状态x<SUB>k</SUB>和策略p<SUB>kn</SUB>的函数，即V<SUB>kn</SUB>(x<SUB>k</SUB>,p<SUB>kn</SUB>)。在x<SUB>k</SUB>给定时指标函数V<SUB>kn</SUB>对p<SUB>kn</SUB>的最优值称为<DFN>最优值函数</DFN><DFN>(optimal 
      value function)</DFN>，记作f<SUB>k</SUB>(x<SUB>k</SUB>)，即</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435276.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT 
      size=4>其中opt可根据具体情况取max或min。上式的意义是，对于某个阶段k的某个状态x<SUB>k</SUB>，从该阶段k到最终目标阶段n的最优指标函数值等于从x<SUB>k</SUB>出发取遍所有能策略p<SUB>kn</SUB>所得到的最优指标值中最优的一个。</FONT></DIV>
      <DIV><FONT size=4><DFN>7</DFN><DFN>）最优策略和最优轨线</DFN></FONT></DIV>
      <DIV><FONT 
      size=4>使指标函数V<SUB>kn</SUB>达到最优值的策略是从k开始的后部子过程的最优策略，记作p<SUB>kn</SUB><SUP>*</SUP>={u<SUB>k</SUB><SUP>*</SUP>,..u<SUB>n</SUB><SUP>*</SUP>},p<SUB>1n</SUB><SUP>*</SUP>又是全过程的最优策略，简称<DFN>最优策略</DFN><DFN>(optimal 
      policy)</DFN>。从初始状态x<SUB>1</SUB>(=x<SUB>1</SUB><SUP>*</SUP>)出发，过程按照p<SUB>1n</SUB><SUP>*</SUP>和状态转移方程演变所经历的状态序列{x<SUB>1</SUB><SUP>*</SUP>,x<SUB>2</SUB><SUP>*</SUP>,..,x<SUB>n+1</SUB><SUP>*</SUP>}称<DFN>最优轨线</DFN><DFN>(optimal 
      trajectory)</DFN>。</FONT></DIV>
      <DIV><FONT size=4><B>三、动态规划的基本定理和基本方程</B><B></B></FONT></DIV>
      <DIV><FONT 
      size=4>动态规划发展的早期阶段，从简单逻辑出发给出了所谓最优性原理，然后在最优策略存在的前提下导出基本方程，再由这个方程求解最优策略。后来在动态规划的应用过程中发现，<STRONG>最优性原理不是对任何决策过程普遍成立，它与基本方程不是无条件等价，二者之间也不存在任何确定的蕴含关系</STRONG>。基本方程在动态规划中起着更为本质的作用。</FONT></DIV>
      <DIV><FONT size=4><B>[</B><B>基本定理</B><B>]<A 
      name=basicthem></A>&nbsp;&nbsp; 
      </B>对于初始状态x<SUB>1</SUB>∈X<SUB>1</SUB>，策略p<SUB>1n</SUB><SUP>*</SUP>={u<SUB>1</SUB><SUP>*</SUP>,..u<SUB>n</SUB><SUP>*</SUP>}是最优策略的充要条件是对于任意的k,1<K<=N,有< 
      DIV> </FONT>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435116.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4><B>四、动态规划的适用条件</B><B></B></FONT></DIV>
      <DIV><FONT 
      size=4>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性。</FONT></DIV>
      <DIV><FONT size=4><B>1.</B><B>最优化原理（最优子结构性质）</B></FONT><A 
      name=optimality></A><B></B></DIV>
      <DIV><FONT 
      size=4>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有<DFN>最优子结构性质</DFN>。</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435413.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT 
      size=4>这两个问题看起来很相似。但实质上是不同的。为了方便讨论，我将每个顶点标记了号码。由于必然经过最右边的顶点7，所以一条路(P1-P2)可以看成两条路（P1-7）与(P2-7)的结合。所以，这个问题的状态可以用两条道路结合的形式表示。我们可以把这些状态中，两条路中起始顶点相同的状态归于一个阶段，设为阶段[P1,P2]。</FONT></DIV>
      <DIV><FONT 
      size=4>那么，对于Bitonic旅行路线问题来说，阶段[P1,P2]如果可以由阶段[Q1,Q2]推出，则必须满足的条件就是:P1<Q1或P2<Q2。例如，阶段[3,4]中的道路可以由阶段[3,5]中的道路加一条边4-5得出，而阶段[3,5]的状态却无法由阶段[3,4]中的状态得出，因为BITONIC旅行路线要求必须严格地由左到右来旅行。所以如果我们已经知道了阶段[3,4]中的状态，则阶段[3,5]中的状态必然已知。因此我们可以说，BITONIC问题满足<DFN>无后向性</DFN>，可以用动态规划来解决。</FONT></DIV>
      <DIV><FONT 
      size=4>有些问题乍一看好像有后向性，但如果按照某种合理的方式重新划分阶段，就可以发现其本质上是无后向性的，所以关键是阶段的合理划分，这一点将在</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter7.htm"><FONT 
      face=宋体 size=4>动态规划的技巧</FONT></A><FONT size=4>中详细阐述。</FONT></DIV>
      <DIV><FONT size=4><B>3.</B><B>子问题的重叠性</B></FONT><A 
      name=repeate></A><B></B></DIV>
      <DIV><FONT 
      size=4>在例1中我们看到，动态规划将原来具有指数级复杂度的搜索算法改进成了具有多项式时间的算法。其中的关键在于<STRONG>解决冗余</STRONG>，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。以</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter3.htm#example3#example3"><FONT 
      face=宋体 size=4>Bitonic旅行路线问题</FONT></A><FONT 
      size=4>为例，这个问题也可以用搜索算法来解决。动态规划的时间复杂度为O(n<SUP>2</SUP>)，搜索算法的时间复杂度为O(n!) 
      ，但从空间复杂度来看，动态规划算法为O(n<SUP>2</SUP>)，而搜索算法为O(n)，搜索算法反而优于动态规划算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间。</FONT></DIV>
      <DIV><FONT 
      size=4>设原问题的规模为n，容易看出，当子问题树中的子问题总数是n的超多项式函数，而不同的子问题数只是n的多项式函数时，动态规划法显得特别有意义，此时动态规划法具有线性时间复杂性。所以，能够用动态规划解决的问题还有一个显著特征：<DFN>子问题的重叠性</DFN>。这个性质并不是动态规划适用的必要条件，但是如果该性质无法满足，动态规划算法同其他算法相比就不具备优势。</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435592.htm" 
      border=0></FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435182.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>图5 动态规划设计的一般模式</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;上述提供了动态规划方法的一般模式，对于简单的动态规划问题，可以按部就班地进行动态规划的设计。</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;下面，给出一个利用动态规划方法求解的典型例子。&nbsp;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;【例题6】数字三角形问题。图6示出了一个数字三角形宝塔。数字三角形中的数字为不超过100的整数。现规定从最顶层走到最底层，每一步可沿左斜线向下或右斜线向下走。</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;任务一：假设三角形行数≤10，键盘输入一个确定的整数值M，编程确定是否存在一条路径，使得沿着该路径所经过的数字的总和恰为M，若存在则给出所有路径，若不存在，则输出“NO&nbsp;Answer!”字样。</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;任务二：假设三角形行数≤100，编程求解从最顶层走到最底层的一条路径，使得沿着该路径所经过的数字的总和最大，输出最大值。</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;输人数据：由文件输入数据，任务一中文件第一行是三角形的行数N和整数值&nbsp;M。以后的N行分别是从最顶层到最底层的每一层中的数字。任务二中文件数据格式同任务一，只是第一行中没有整数值M。在例子中任务二的文件数据表示如下：</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435176.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;【分析】对于这一问题，很容易想到用枚举的方法去解决，即列举出所有路径并记录每一条路径所经过的数字总和。然后判断数字总和是否等于给定的整数值M或寻找出最大的数字总和，这一想法很直观，而且对于任务一，由于数字三角形的行数不大(&lt;＝10)，因此其枚举量不是很大，应该能够实现。但对于任务二，如果用枚举的方法，当三角形的行数等于100时，其枚举量之大是可想而知的，显然，枚举法对于任务二的求解并不适用。其实，只要对对任务二稍加分析，就可以得出一个结论：</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;如果得到一条由顶至底的某处的一条最佳路径，那么对于该路径上的每一个中间点来说，由顶至该中间点的路径所经过的数字和也为最大。因此该问题是一个典型的多阶段决策最优化的问题。算法设计与分析如下：</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;对于任务一，合理地确认枚举的方法，可以优化问题的解法。由于从塔顶到底层每次都只有两种走法，即左或右。设“0”表示左，&nbsp;&nbsp;“1”表示右，对于层数为N的数字塔，从顶到底的一种走法可用一个N-1位的二进制数表示。如例中二进制数字串1011，其对应的路径应该是：8―1―4―6。这样就可以用一个N―l位的二进制数来模拟走法和确定解的范围。穷举出从0到2<SUP>n</SUP>-1个十进制数所对应的N-1位二进制串对应的路径中的数字总和，判定其是否等于M而求得问题的解。</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;对于任务二，采用动态规划中的顺推解法。按三角形的行划分阶段，若行数为&nbsp;n，则可把问题看做一个n-1个阶段的决策问题。从始点出发，依顺向求出第一阶段、第二阶段……第n―1阶段中各决策点至始点的最佳路径，最终求出始点到终点的最佳路径。</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;设：f<SUB>k</SUB>(U<SUB>k</SUB>)为从第k阶段中的点Uk至三角形顶点有一条最佳路径，该路径所经过的数字的总和最大，f<SUB>k</SUB>(U<SUB>k</SUB>)表示为这个数字和；</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;由于每一次决策有两个选择，或沿左斜线向下，或沿右斜线向下，因此设：</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;U<SUB>k1</SUB>为k-1阶段中某点U<SUB>k</SUB>沿左斜线向下的点；</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;U<SUB>k2</SUB>为k-1阶段中某点U<SUB>k</SUB>沿右斜线向下的点；</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;d<SUB>k</SUB>(U<SUB>k1</SUB>)为k阶段中U<SUB>k1</SUB>的数字；d<SUB>k</SUB>(U<SUB>k2</SUB>)为k阶段中U<SUB>k2</SUB>的数字。</FONT></DIV>
      <DIV><FONT 
size=4>&nbsp;&nbsp;&nbsp;&nbsp;因而可写出顺推关系式(状态转移方程)为：</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;f<SUB>k</SUB>(U<SUB>k</SUB>)=max{f<SUB>k-1</SUB>(U<SUB>k</SUB>)+d<SUB>k</SUB>(U<SUB>k1</SUB>)，f<SUB>k-1</SUB>(U<SUB>k</SUB>)+d<SUB>k</SUB>(U<SUB>k2</SUB>)}(k=1，2，3，…，n)</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;f<SUB>0</SUB>(U<SUB>0</SUB>)＝0</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;经过一次顺推，便可分别求出由顶至底N个数的N条路径，在这N条路径所经过的N个数字和中，最大值即为正确答案。</FONT></DIV>
      <DIV><FONT size=4><B>六、动态规划的基本思想</B><B></B></FONT></DIV>
      <DIV><A name=formdp></A><FONT 
      size=4>前文主要介绍了动态规划的一些理论依据，我们将前文所说的具有明显的阶段划分和状态转移方程的动态规划称为<DFN>标准动态规划</DFN>，这种标准动态规划是在研究多阶段决策问题时推导出来的，具有严格的数学形式，适合用于理论上的分析。在实际应用中，许多问题的阶段划分并不明显，这时如果刻意地划分阶段法反而麻烦。一般来说，只要该问题可以划分成规模更小的子问题，并且原问题的最优解中包含了子问题的最优解（即满足最优子化原理），则可以考虑用动态规划解决。</FONT></DIV>
      <DIV><FONT size=4>动态规划的实质是<STRONG><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/divide_and_conquer/chapter1.htm"><FONT 
      face=宋体 
      size=2>分治思想</FONT></A></STRONG>和<STRONG>解决冗余</STRONG>，因此，<DFN>动态规划</DFN>是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免计算重复的子问题，以解决最优化问题的算法策略。</FONT></DIV>
      <DIV><FONT size=4>由此可知，动态规划法与</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/divide_and_conquer/index.htm"><FONT 
      face=宋体 size=4>分治法</FONT></A><FONT size=4>和</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/greedy/index.htm"><FONT 
      face=宋体 size=4>贪心法</FONT></A><FONT 
      size=4>类似，它们都是将问题实例归纳为更小的、相似的子问题，并通过求解子问题产生一个全局最优解。其中贪心法的当前选择可能要依赖已经作出的所有选择，但不依赖于有待于做出的选择和子问题。因此贪心法自顶向下，一步一步地作出贪心选择；而分治法中的各个子问题是独立的 
      (即不包含公共的子子问题)，因此一旦递归地求出各子问题的解后，便可自下而上地将子问题的解合并成问题的解。但不足的是，如果当前选择可能要依赖子问题的解时，则难以通过局部的贪心策略达到全局最优解；如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题。</FONT></DIV>
      <DIV><FONT 
      size=4>解决上述问题的办法是利用动态规划。该方法主要应用于最优化问题，这类问题会有多种可能的解，每个解都有一个值，而动态规划找出其中最优(最大或最小)值的解。若存在若干个取最优值的解的话，它<STRONG>只取其中的一个</STRONG>。在求解过程中，该方法也是通过求解局部子问题的解达到全局最优解，但与分治法和贪心法不同的是，动态规划允许这些子问题不独立，(亦即各子问题可包含公共的子子问题)也允许其通过自身子问题的解作出选择，该方法对每一个子问题只解一次，并将结果保存起来，避免每次碰到时都要重复计算。</FONT></DIV>
      <DIV><FONT 
      size=4>因此，动态规划法所针对的问题有一个显著的特征，即它所对应的子问题树中的子问题呈现大量的重复。动态规划法的关键就在于，<STRONG>对于重复出现的子问题，只在第一次遇到时加以求解，并把答案保存起来，让以后再遇到时直接引用，不必重新求解。</STRONG></FONT></DIV>
      <DIV><FONT size=4><B>七、动态规划算法的基本步骤</B><B></B></FONT></DIV>
      <DIV><FONT size=4>设计一个</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter4.htm#formdp"><FONT 
      face=宋体 size=4>标准的动态规划算法</FONT></A><FONT 
size=4>，通常可按以下几个步骤进行：</FONT></DIV>
      <DIV><FONT 
      size=4><B>划分阶段：</B>按照问题的时间或空间特征，把问题分为若干个阶段。注意这若干个阶段一定要是有序的或者是可排序的（即无后向性），否则问题就无法用动态规划求解。 
      </FONT></DIV>
      <DIV><FONT 
      size=4><B>选择状态：</B>将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 
      </FONT></DIV>
      <DIV><FONT 
      size=4><B>确定决策并写出状态转移方程：</B>之所以把这两步放在一起，是因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以，如果我们确定了决策，状态转移方程也就写出来了。但事实上，我们常常是反过来做，根据相邻两段的各状态之间的关系来确定决策。 
      </FONT></DIV>
      <DIV><B><FONT size=4>写出规划方程（包括边界条件）：</FONT></B><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter2.htm#BasicEqn"><FONT 
      face=宋体 size=4>动态规划的基本方程</FONT></A><FONT 
      size=4>是规划方程的通用形式化表达式。一般说来，只要阶段、状态、决策和状态转移确定了，这一步还是比较简单的。 
      </FONT></DIV><FONT size=4>动态规划的主要难点在于理论上的设计，一旦设计完成，实现部分就会非常简单。根据</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter2.htm#BasicEqn"><FONT 
      face=宋体 size=4>动态规划的基本方程</FONT></A><FONT 
      size=4>可以直接递归计算最优值，但是一般将其改为递推计算，实现的大体上的框架如下：</FONT></DIV></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV>
      <DIV><B><FONT size=4>标准动态规划的基本框架</FONT></B><A name=mainframe></A></DIV>
      <DIV><FONT size=4>1.&nbsp; 对fn+1(xn+1)初始化;&nbsp;&nbsp;&nbsp; 
      {边界条件}</FONT></DIV>
      <DIV><FONT size=4>2.&nbsp; for k:=n downto 1 do </FONT></DIV>
      <DIV><FONT size=4>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for 
      每一个x<SUB>k</SUB>∈X<SUB>k</SUB> do</FONT></DIV>
      <DIV><FONT size=4>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for 
      每一个u<SUB>k</SUB>∈U<SUB>k</SUB>(x<SUB>k</SUB>) do</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT 
      size=4>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      f<SUB>k(</SUB>x<SUB>k</SUB>):=一个极值;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      {∞或－∞}</FONT></DIV>
      <DIV><FONT 
      size=4>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      x<SUB>k+1</SUB>:=T<SUB>k</SUB>(x<SUB>k</SUB>,u<SUB>k</SUB>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      {状态转移方程}</FONT></DIV>
      <DIV><FONT 
      size=4>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      t:=φ(f<SUB>k+1</SUB>(x<SUB>k+1</SUB>),v<SUB>k</SUB>(x<SUB>k</SUB>,u<SUB>k</SUB>));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      {基本方程(9)式}</FONT></DIV>
      <DIV><FONT 
      size=4>8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      if&nbsp; t比f<SUB>k</SUB>(x<SUB>k</SUB>)更优 then 
      f<SUB>k</SUB>(x<SUB>k</SUB>):=t; 
      {计算f<SUB>k</SUB>(x<SUB>k</SUB>)的最优值}</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end;&nbsp; </FONT></DIV>
      <DIV><FONT size=4>9.&nbsp; 
      t:=一个极值;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      {∞或－∞}</FONT></DIV>
      <DIV><FONT size=4>10. for 每一个x<SUB>1</SUB>∈X<SUB>1</SUB> do</FONT></DIV>
      <DIV><FONT size=4>11.&nbsp;&nbsp;&nbsp;&nbsp; if 
      f<SUB>1</SUB>(x<SUB>1</SUB>)比t更优 then 
      t:=f<SUB>1</SUB>(x<SUB>1</SUB>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      {按照10式求出最优指标}</FONT></DIV>
      <DIV><FONT size=4>12. 输出t;</FONT></DIV>
      <DIV><FONT size=4>但是，实际应用当中经常不显式地按照上面步骤设计动态规划，而是按以下几个步骤进行：</FONT></DIV>
      <DIV><FONT size=4>1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      分析最优解的性质，并刻划其结构特征。 </FONT></DIV>
      <DIV><FONT size=4>2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 递归地定义最优值。 
      </FONT></DIV>
      <DIV><FONT size=4>3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      以自底向上的方式或自顶向下的记忆化方法（备忘录法）计算出最优值。 </FONT></DIV>
      <DIV><FONT size=4>4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      根据计算最优值时得到的信息，构造一个最优解。 </FONT></DIV>
      <DIV><FONT 
      size=4>步骤(1)--(3)是动态规划算法的基本步骤。在只需要求出最优值的情形，步骤(4)可以省略，若需要求出问题的一个最优解，则必须执行步骤(4)。此时，在步骤(3)中计算最优值时，通常需记录更多的信息，以便在步骤(4)中，根据所记录的信息，快速地构造出一个最优解。</FONT></DIV>
      <DIV><FONT size=4><B>八、动态规划的实例分析</B><B></B></FONT></DIV>
      <DIV><FONT 
      size=4>下面我们将通过实例来分析动态规划的设计步骤和具体应用。例1已经在前文介绍过了。例1和例2是标准的动态规划，有明显的阶段和状态转移方程；例3、例4、例5、例6是没有明显阶段划分的动态规划，也是一般常见的形式，其中对例4、例5、例6作了比较详细的分析；例7是比较特殊的动态规划，例8是两重动态规划（即为了解决问题要进行两次动态规划）的例子。</FONT></DIV></DIV></DIV></DIV></DIV></DIV></DIV>
      <DIV><B><FONT size=4></FONT></B>&nbsp;</DIV>
      <DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/introduction.htm#example1"><FONT 
      face=宋体 size=4>例1 最短路径问题</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/production/solution.htm"><FONT 
      face=宋体 size=4>例2 生产计划问题</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/bitonic/problem.htm"><FONT 
      face=宋体 size=4>例3 Bitonic旅行路线问题</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/problem.htm"><FONT 
      face=宋体 size=4>例4 计算矩阵连乘积</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/LCS/problem.htm"><FONT 
      face=宋体 size=4>例5 最长公共子序列</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/polygon/problem.htm"><FONT 
      face=宋体 size=4>例6 凸多边形的最优三角剖分问题</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/polygon_cal/problem.htm"><FONT 
      face=宋体 size=4>例7 多边形计算</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/character_recognition/problem.htm"><FONT 
      face=宋体 size=4>例8 字符识别</FONT></A><FONT size=4> </FONT></DIV>
      <DIV><FONT size=4>更多实例请参阅</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/index.html?by_strategy/dynamic_programming.htm" 
      target=_top><FONT face=宋体 size=4>动态规划问题集</FONT></A></DIV>
      <DIV><FONT face=宋体 size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4><B>例</B><B>1 </B><B>生产计划问题</B><B></B></FONT></DIV>
      <DIV><FONT size=4><B>问题描述</B><B>&nbsp;&nbsp;&nbsp; 
      </B>工厂生产某种产品，每单位(千件)的成本为1(千元)，每次开工的固定成本为3(千元)，工厂每季度的最大生产能力为6(千件)。经调查，市场对该产品的需求量第一、二、三、四季度分别为 
      2，3，2，4(千件)。如果工厂在第一、二季度将全年的需求都生产出来，自然可以降低成本(少付固定成本费)，但是对于第三、四季度才能上市的产品需付存储费，每季每千件的存储费为0.5(千元)。还规定年初和年末这种产品均无库存。试制订一个生产计划，即安排每个季度的产量，使一年的总费用(生产成本和存储费)最少。 
      </FONT></DIV>
      <DIV><B><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/production/solution.htm"><FONT 
      face=宋体 size=4>参考解答</FONT></A><FONT size=4>&nbsp;&nbsp; </FONT></B><FONT 
      size=4>这是一个明显的多阶段问题，我们按照计划时间自然划分阶段，状态定义为每阶段开始时的存储量x<SUB>k</SUB>，决策为每个阶段的产量u<SUB>k</SUB>，记每个阶段的需求量（已知）为d<SUB>k</SUB>，则状态转移方程为：</FONT></DIV>
      <DIV><FONT size=4></FONT></DIV>
      <DIV><FONT 
      size=4>设每个阶段开工固定成本费用为a，生产单位数量产品的成本为b，每阶段单位数量产品的存储费用为ｃ，阶段指标为阶段的生产成本费用和存储费用之和，即：</FONT></DIV>
      <DIV><FONT size=4></FONT></DIV>
      <DIV><FONT 
      size=4>指标函数V<SUB>kn</SUB>为v<SUB>k</SUB>之和，最优值函数f<SUB>k</SUB>(x<SUB>k</SUB>)为从第k阶段的状态x<SUB>k</SUB>出发到过程终结的最小费用，满足</FONT></DIV>
      <DIV><FONT size=4></FONT></DIV>
      <DIV><FONT 
      size=4>其中允许决策集合U<SUB>k</SUB>由每阶段的最大生产能力决定，设过程终结时允许存储量为x<SUP>0</SUP><SUB>n+1</SUB>，则终端条件为：</FONT></DIV>
      <DIV><FONT size=4></FONT></DIV>
      <DIV><FONT size=4>将以上各式代入到</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter5.htm#mainframe"><FONT 
      face=宋体 size=4>标准动态规划的框架</FONT></A><FONT size=4>中，就可以求得最优解。</FONT></DIV>
      <DIV><FONT size=4><B>例</B><B>2&nbsp; 
      Bitonic</B><B>旅行路线问题</B><B></B></FONT></DIV>
      <DIV><FONT size=4><B>问题描述</B><B>&nbsp;&nbsp; 
      </B>欧几里德货郎担问题是对平面给定的n个点确定一条连结各点的、闭合的游历路线问题。图7(a)给出了七个点问题的解。Bitonic旅行路线问题是欧几里德货郎担问题的简化，这种旅行路线先从最左边开始，<B>严格地</B>由左至右到最右边的点，然后再<B>严格地</B>由右至左到出发点，求路程最短的路径长度。图7（b）给出了七个点问题的解。</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435240.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>请设计一种多项式时间的算法，解决Bitonic旅行路线问题。 </FONT></DIV>
      <DIV><B><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/bitonic/solution.htm"><FONT 
      face=宋体 size=4>参考解答</FONT></A><FONT size=4>&nbsp;&nbsp;&nbsp; 
      </FONT></B><FONT 
      size=4>首先将n个点按X坐标递增的顺序排列成一个序列L=&lt;点1，点2，…，点n&gt;。显然L[n]为最右点，L[1]为最左点。由于点1往返经过二次(出发一次，返回一次)，因此点1拆成两个点：L[0]=L[1]=点1。</FONT></DIV>
      <DIV><FONT size=4>设：</FONT></DIV>
      <DIV><FONT size=4>W<SUB>i,j </SUB>-- 边<I,J>的距离； </FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435903.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>由该公式知计算C=AB总共需要pqr次的数乘。</FONT></DIV>
      <DIV><FONT 
      size=4>现在的问题是，给定n个矩阵{A<SUB>1</SUB>,A<SUB>2</SUB>,…,A<SUB>n</SUB>}。其中A<SUB>i</SUB>与A<SUB>i+1</SUB>是可乘的，i=1,2,…,n-1。要求计算出这n个矩阵的连乘积A<SUB>1</SUB>A<SUB>2</SUB>…A<SUB>n</SUB>。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      由于矩阵乘法满足结合律，故连乘积的计算可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。若一个矩阵连乘积的计算次序已完全确定，也就是说该连乘积已完全加括号，则我们可以通过反复调用两个矩阵相乘的标准算法计算出矩阵连乘积。完全加括号的矩阵连乘积可递归地定义为：</FONT></DIV>
      <DIV><FONT size=4>单个矩阵是完全加括号的； </FONT></DIV>
      <DIV><FONT size=4>若矩阵连乘积A是完全加括号的，则A可表示为两个完全加括号的矩阵连乘积B和C的乘积并加括号，即A=(BC)。 
      </FONT></DIV>
      <DIV><FONT size=4>例如，矩阵连乘积A<SUB>1</SUB>A<SUB>2</SUB>A<SUB>3</SUB> 
      A<SUB>4</SUB>可以有以下5种不同的完全加括号方式：</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      (A<SUB>1</SUB>(A<SUB>2</SUB>(A<SUB>3</SUB>A<SUB>4</SUB>)))，</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      (A<SUB>1</SUB>((A<SUB>2</SUB>A<SUB>3</SUB>)A<SUB>4</SUB>)),</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      ((A<SUB>1</SUB>A<SUB>2</SUB>)(A<SUB>3</SUB>A<SUB>4</SUB>)),</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      ((A<SUB>1</SUB>(A<SUB>2</SUB>A<SUB>3</SUB>))A<SUB>4</SUB>),</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      (((A<SUB>1</SUB>A<SUB>2</SUB>)A<SUB>3</SUB>)A<SUB>4</SUB>)。</FONT></DIV>
      <DIV><FONT 
      size=4>每一种完全加括号方式对应于一种矩阵连乘积的计算次序，而这种计算次序与计算矩阵连乘积的计算量有着密切的关系。</FONT></DIV>
      <DIV><FONT 
      size=4>为了说明在计算矩阵连乘积时加括号方式对整个计算量的影响，我们来看一个计算3个矩阵{A<SUB>1</SUB>，A<SUB>2</SUB>，A<SUB>3</SUB>}的连乘积的例子。设这3个矩阵的维数分别为10×100，100×5和5×50。若按第一种加括号方式((A<SUB>1</SUB>A<SUB>2</SUB>)A<SUB>3</SUB>)来计算，总共需要10×100×5+10×5×50=7500次的数乘。若按第二种加括号方式(A<SUB>1</SUB>(A<SUB>2</SUB>A<SUB>3</SUB>))来计算，则需要的数乘次数为100×5×50+10×100×50=75000。第二种加括号方式的计算量是第一种加括号方式的计算量的10倍。由此可见，在计算矩阵连乘积时，加括号方式，即计算次序对计算量有很大影响。</FONT></DIV>
      <DIV><FONT 
      size=4>于是，人们自然会提出矩阵连乘积的最优计算次序问题，即对于给定的相继n个矩阵{A<SUB>1</SUB>,A<SUB>2</SUB>,…,A<SUB>n</SUB>}(其中A<SUB>i</SUB>的维数为p<SUB>i-1</SUB>×p<SUB>i</SUB> 
      ，i=1,2,…,n)，如何确定计算矩阵连乘积A<SUB>1</SUB>A<SUB>2</SUB>…A<SUB>n</SUB>的一个计算次序(完全加括号方式)，使得依此次序计算矩阵连乘积需要的数乘次数最少。</FONT></DIV>
      <DIV><FONT size=4><B>说明</B>：计算两个均为n×n的矩阵(即n阶方阵)相乘还有一种</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/commonalg/misc/strassen/strassen.htm"><FONT 
      face=宋体 size=4>Strassen矩阵乘法</FONT></A><FONT size=4>，利用</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/divide_and_conquer/index.htm"><FONT 
      face=宋体 size=4>分治思想</FONT></A><FONT 
      size=4>将2个n阶矩阵乘积所需时间从标准算法的<I>O</I>(n<SUP>3</SUP>)改进到<I>O</I>(n<SUP>log7</SUP>)=<I>O</I>(n<SUP>2.81</SUP>)。目前计算两个n阶方阵相乘最好的计算时间上界是O(n<SUP>2.367</SUP>)。但无论如何，所需的乘法次数总随两个矩阵的阶而递增。在这道题中只考虑采用标准公式计算两个矩阵的乘积。</FONT></DIV>
      <DIV><B><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm"><FONT 
      face=宋体 size=4>参考解答</FONT></A><FONT size=4>&nbsp;&nbsp;&nbsp; 
      </FONT></B><FONT 
      size=4>解这个问题的最容易想到的方法是穷举搜索法。也就是列出所有可能的计算次序，并计算出每一种计算次序相应需要的计算量，然后找出最小者。然而，这样做计算量太大。事实上，对于n个矩阵的连乘积，设有P(n)个不同的计算次序。由于我们可以首先在第k个和第k+1个矩阵之间将原矩阵序列分为两个矩阵子序列，k=1,2,…,n-1；然后分别对这两个矩阵子序列完全加括号；最后对所得的结果加括号，得到原矩阵序列的一种完全加括号方式。所以关于P(n)，我们有递推式如下：</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435531.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 下面我们来考虑用</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/index.htm"><FONT 
      face=宋体 size=4>动态规划</FONT></A><FONT 
      size=4>法解矩阵连乘积的最优计算次序问题。此问题是动态规划的典型应用之一。</FONT></DIV>
      <DIV><FONT size=4>1.分析最优解的结构</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      首先，为方便起见，将矩阵连乘积A<SUB>i</SUB>A<SUB>i+1</SUB>…A<SUB>j</SUB>简记为A<SUB>i…j</SUB>。我们来看计算A<SUB>1…n</SUB>的一个最优次序。设这个计算次序在矩阵A<SUB>k</SUB>和A<SUB>k+1</SUB>之间将矩阵链断开，1&lt;=k<N，则完全加括号方式为((A<SUB>1</SUB>…A<SUB>k</SUB>)(A<SUB>k+1</SUB>…A<SUB>n</SUB>))。照此，我们要先计算A<SUB>1…k</SUB>和A<SUB>k+1…n</SUB>，然后，将所得的结果相乘才得到A<SUB>1…n</SUB>。显然其总计算量为计算A<SUB>1…k</SUB>的计算量加上计算A<SUB>k+1…n</SUB>的计算量，再加上A<SUB>1…k</SUB>与A<SUB>k+1…n</SUB>相乘的计算量。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      这个问题的一个关键特征是：计算A<SUB>1…n</SUB>的一个最优次序所包含的计算A<SUB>1…k</SUB>的次序也是最优的。事实上，若有一个计算A<SUB>1…k</SUB>的次序需要的计算量更少，则用此次序替换原来计算A<SUB>1…k</SUB>的次序，得到的计算A<SUB>1…n</SUB>的次序需要的计算量将比最优次序所需计算量更少，这是一个矛盾。同理可知，计算A<SUB>1…n</SUB>的一个最优次序所包含的计算矩阵子链A<SUB>k+1…n</SUB>的次序也是最优的。根据该问题的指标函数的特征也可以知道该问题满足最优化原理。另外，该问题显然满足无后向性，因为前面的矩阵链的计算方法和后面的矩阵链的计算方法无关。</FONT></DIV>
      <DIV><FONT size=4>2.建立递归关系</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 对于矩阵连乘积的最优计算次序问题，设计算A<SUB>i…j</SUB> 
      ,1≤i≤j≤n，所需的最少数乘次数为m[i,j]，原问题的最优值为m[1,n]。</FONT></DIV>
      <DIV><FONT 
      size=4>当i=j时，A<SUB>i…j</SUB>=A<SUB>i</SUB>为单一矩阵，无需计算，因此m[i,i]=0，i=1,2,…,n 
      ； </FONT></DIV>
      <DIV><FONT 
      size=4>当i<J时，可利用最优子结构性质来计算M[I,J]。事实上，若计算A<SUB>i…j</SUB>的最优次序在A<SUB>k</SUB>和A<SUB>k+1</SUB>之间断开，i≤k<J，则：M[I,J]=M[I,K]+M[K+1,J]+P<SUB>i-1</SUB>p<SUB>k</SUB>p<SUB>j</SUB> 
      </FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      由于在计算时我们并不知道断开点A的位置，所以A还未定。不过k的位置只有j-i个可能，即k∈{i,i+1,…,j-1}。因此k是这j-i个位置中计算量达到最小的那一个位置。从而m[i,j]可以递归地定义为：</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435749.htm" 
      border=0></FONT></DIV></DIV></DIV></DIV>
      <DIV>
      <DIV><FONT size=4>&nbsp;&nbsp; 用动态规划算法解此问题，可依据</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#f2-1#f2-1"><FONT 
      face=宋体 size=4>递归式(2.1)</FONT></A><FONT 
      size=4>以<B><I>自底向上的方式</I></B>进行计算，在计算过程中，保存已解决的子问题答案，每个子问题只计算一次，而在后面需要时只要简单查一下，从而避免大量的重复计算，最终得到多项式时间的算法。下面所给出的计算m[i,j]动态规划算法中，输入是序列P={p<SUB>0</SUB>,p<SUB>1</SUB>,…,p<SUB>n</SUB>}，输出除了最优值m[i,j]外，还有使</FONT></DIV>
      <DIV><FONT size=4>m[i,j] = m[i,k] + m[k+1,j] + 
      p<SUB>i-1</SUB>p<SUB>k</SUB>p<SUB>j</SUB></FONT></DIV>
      <DIV><FONT size=4>达到最优的断开位置k=s[i,j]，1≤i≤j≤n 。</FONT></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4>Procedure MATRIX_CHAIN_ORDER(p); 
      {计算矩阵链连乘的最优断开位置}</FONT><A name=MATRIX_CHAIN_ORDER></A></DIV>
      <DIV><FONT size=4>var</FONT></DIV>
      <DIV><FONT size=4>i,j,k,q:integer;</FONT></DIV>
      <DIV><FONT size=4>begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp; for j:=1 to n do {矩阵链的长度为n}</FONT></DIV>
      <DIV><FONT size=4>&nbsp; for i:=j downto 1 do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i=j then 
      m[i,j]:=0</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      else begin</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      m[i,j]:=∞;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      for k:=i to j-1 do</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      q:=m[i,k]+m[k+1,j]+p[i-1]*p[k]*p[j];</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if q<M[I,J] DIV 
      then<> </FONT>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      m[i,j]:=q;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      s[i,j]:=k; </FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      {s[i,j]记录计算A[i..j]的最优断开位置k}</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      &nbsp;end;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; end;</FONT></DIV>
      <DIV><FONT size=4>end; </FONT></DIV>
      <DIV><FONT size=4>该算法按照</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; m[1,1]</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; m[2,2]&nbsp;&nbsp; 
m[1,2]</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; m[3,3]&nbsp;&nbsp; m[2,3]&nbsp;&nbsp; 
      m[1,3]</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; m[n,n]&nbsp;&nbsp; m[n-1,n] ... 
      ....&nbsp; ... m[1,n]</FONT></DIV>
      <DIV><FONT size=4>的顺序根据</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#f2-1#f2-1"><FONT 
      face=宋体 size=4>公式(2.1)</FONT></A><FONT size=4>计算m[i,j]。</FONT></DIV>
      <DIV><FONT 
      size=4>该算法的计算时间上界为<I>O</I>(n<SUP>3</SUP>)。算法所占用的空间显然为<I>O</I>(n<SUP>2</SUP>)。由此可见，动态规划算法比穷举搜索法要有效得多。</FONT></DIV>
      <DIV><FONT size=4>4.构造最优解</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; </FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#MATRIX_CHAIN_ORDER#MATRIX_CHAIN_ORDER"><FONT 
      face=宋体 size=4>算法MATRIX_CHAIN_ ORDER</FONT></A><FONT 
      size=4>只是计算出了最优值，并未给出最优解。也就是说，通过MATRIX_CHAIN_ORDER的计算，我们只知道计算给定的矩阵连乘积所需的最少数乘次数，还不知道具体应按什么次序来做矩阵乘法才能达到数乘次数最少。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      然而，MATRIX_CHAIN_ORDER己记录了构造一个最优解所需要的全部信息。事实上，s[i,j]中的数k告诉我们计算矩阵链A<SUB>i…j</SUB>的最佳方式应在矩阵A<SUB>k</SUB>和A<SUB>k+1</SUB>之间断开，即最优的加括号方式应为(A<SUB>1...k</SUB>)(A<SUB>k+1…n</SUB>)。因此，从s[i,j]记录的信息可知计算A<SUB>1…n</SUB>的最优加括号方式为 
      (A<SUB>1…s[1,n]</SUB>)(A<SUB>s[1,n]+1…n</SUB>)。而计算A<SUB>1…s[1,n]</SUB>的最优加括号方式为(A<SUB>1…s[1,s[1,n]]</SUB>)(A<SUB>s[1</SUB>,<SUB>s[1,n]]+1…s[1,n]</SUB>)。同理可以确定计算A<SUB>s[1,n]+1…n</SUB>的最优加括号方式在s[s[1,n]+1,n]处断开。…照此递推下去，最终可以确定A<SUB>s[1,n]+1…n</SUB>的最优完全加括号方式，即构造出问题的一个最优解。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      下面的算法MATRIX_CHAIN_MULTIPLY(A,s,i,j)是按s指示的加括号方式计算矩阵链A={A<SUB>1</SUB>,A<SUB>2</SUB>,…,A<SUB>n</SUB>}的子链A<SUB>i…j</SUB>的连乘积的算法。</FONT></DIV>
      <DIV><FONT size=4>Procdeure MATRIX_CHAIN_MULTIPLY(A,s,i,j);</FONT></DIV>
      <DIV><FONT size=4>begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp; if j&gt;i then</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      X←MATRIX_CHAIN_MULTIPLY(A,s,i,s[i,j]);</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      Y←MATRIX_CHAIN_MULTIPLY(A,s,s[i,j]+1,j);</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      return(MATRIX_MULTIPLY(X,Y)); {计算并返回矩阵X*Y的值}</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 
      return(Ai);</FONT></DIV>
      <DIV><FONT size=4>end;</FONT></DIV>
      <DIV><FONT 
      size=4>要计算A<SUB>1…n</SUB>只要调用MATRIX_CHAIN_MULTIPLY(A,s,1,n)即可。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 从</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#MATRIX_CHAIN_ORDER#MATRIX_CHAIN_ORDER"><FONT 
      face=宋体 size=4>算法MATRIX_CHAIN_ ORDER</FONT></A><FONT 
      size=4>可以看出，该算法的有效性依赖于问题本身所具有的三个重要性质：<B>最优子结构性质</B>，<B>无后向性</B>和<B>子问题重叠性质</B>。一般说来，问题所具有的这三个重要性质是该问题</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter3.htm"><FONT 
      face=宋体 size=4>可用动态规划算法求解的基本要素</FONT></A><FONT 
      size=4>，这对于我们在设计求解具体问题的算法时，是否选择动态规划算法具有指导意义。下面我们着重研究<B>最优子结构性质</B>和<B>子问题重叠性质</B>以及动态规划法的一个变形―</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#memo#memo"><B><FONT 
      face=宋体 size=4>备忘录方法</FONT></B></A><FONT size=4>。</FONT></DIV>
      <DIV><FONT size=4>最优子结构</FONT></DIV>
      <DIV><FONT 
      size=4>设计动态规划算法的第1步通常是要刻划最优解的结构。当问题的最优解包含了其子问题的最优解时，称该问题具有<B>最优子结构性质</B>。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。</FONT></DIV>
      <DIV><FONT 
      size=4>在矩阵连乘积最优计算次序问题中，我们注意到，若A<SUB>1…n</SUB>的最优完全加括号方式在A<SUB>k</SUB>和A<SUB>k+1</SUB>之间将矩阵链断开，则由该次序确定的子链A<SUB>1…k</SUB>和A<SUB>k+1…n</SUB>的完全加括号方式也是最优的。也就是说该问题具有最优子结构性质。在分析该问题的最优子结构性质时，我们所用的方法是具有普遍性的。我们首先假设由问题的最优解导出的其子问题的解不是最优的，然后再设法证明在这个假设下可构造出一个比原问题最优解更好的解，从而导致矛盾。</FONT></DIV>
      <DIV><FONT 
      size=4>在动态规划算法中，问题的最优子结构性质使我们能够以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。同时，它也使我们能在相对小的子问题空间中考虑问题。例如，在矩阵连乘积最优计算次序问题中，子问题空间是输人的矩阵链的所有不同的子链，它们的个数为θ(n<SUP>2</SUP>)。因而子问题空间的规模仅为θ(n<SUP>2</SUP>)。</FONT></DIV>
      <DIV><FONT size=4>重叠子问题</FONT></DIV>
      <DIV><FONT 
      size=4>可用动态规划算法求解的问题应具备的另一基本要素是<B>子问题的重叠性质</B>。也就是说，在用递归算法自顶向下解此问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。通常，不同的子问题的个数随输人问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。</FONT></DIV>
      <DIV><FONT size=4>为了说明这一点，我们来看在计算矩阵连乘积最优计算次序时，利用</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#f2-1#f2-1"><FONT 
      face=宋体 size=4>公式(2.1)</FONT></A><FONT 
      size=4>直接计算A<SUB>i…j</SUB>的递归算法。</FONT></DIV>
      <DIV><FONT size=4>Function RECURSIVE_MATRIX_CHAIN(P,i,j);</FONT></DIV>
      <DIV><FONT size=4>begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp; if i=j then return(0);</FONT></DIV>
      <DIV><FONT size=4>&nbsp; m[i,j]:=∞;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; for k:=i to j-1 do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      q:=RECURSIVE_MATRIX_CHAIN(P,i,k)+RECURSIVE_MATRIX_CHAIN(P,k+1,j)+p<SUB>i-1</SUB>p<SUB>k</SUB>p<SUB>j</SUB>;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if q<M[I,J] then 
      m[i,j]:="q;</DIV"> </FONT>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; end</FONT></DIV>
      <DIV><FONT size=4>&nbsp; return(m[i,j]);</FONT></DIV>
      <DIV><FONT size=4>end; </FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435967.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT 
      size=4>因此，直接递归算法RECURSIVE_MATRIX_CHAIN(P,1,n)的计算时间随n指数增长。相比之下，解同一问题的动态规划算法MATRIX_CHAIN_ORDER 
      (P,1,n)只需计算时间O(n<SUP>2</SUP>)。其有效性就在于它<B>充分利用了问题的子问题重叠性质</B>。不同的子问题个数为θ(n<SUP>2</SUP>)，而动态规划算法对于每个不同的子问题只计算一次，不是重复计算多次。由此也可看出，当解某一问题的直接递归算法所产生的递归树中，相同的子问题反复出现，并且不同子问题的个数又相对较少时，用动态规划算法是有效的。</FONT></DIV>
      <DIV><FONT size=4>备忘录方法</FONT><A name=memo></A></DIV>
      <DIV><FONT 
      size=4>动态规划算法的一个变形是备忘录方法。与动态规划算法一样，备忘录方法用一个表格来保存已解决的子问题的答案，在再碰到该子问题时，只要简单地查看该子问题的解答，而不必重新求解。不同的是，备忘录方法采用的是自顶向下的递归方式，而动态规划算法采用的是自底向上的非递归方式。我们看到，备忘录方法的控制结构与直接递归方法的控制结构相同，区别仅在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。</FONT></DIV>
      <DIV><FONT 
      size=4>备忘录方法为每个子问题建立一个记录项，初始化时，该记录项存入一个特殊的值，表示该子问题尚末求解。在求解过程中，对碰到的每个子问题，首先查看其相应的记录项。若记录项中存储的是初始化时存入的特殊值，则表示该子问题是第一次遇到，此时需要对该子问题进行求解，并把得到的解保存在其相应的记录项中，以备以后查看。若记录项中存储的巴不是初始化时存入的特殊值，则表示该子问题己被求解过，其相应的记录项中存储的是该子问题的解答。此时，只要从记录项中取出读子问题的解答即可，不必重新计算。</FONT></DIV>
      <DIV><FONT 
      size=4>下面的算法MEMOIZED_MATRIX_CHAIN(P)是解矩阵连乘积最优计算次序问题的备忘录方法。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp; <B>Procedure</B> 
      MEMOIZED_MATRIX_CHAIN(P);</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      n:=length[P]-1;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i:=1 to n 
      do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for 
      j:=1 to n do </FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      m[i,j]:=∞;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      return(LOOKUP_CHAIN(P,l,n));</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>Function</B> 
      LOOKUP_CHAIN(P,i,j);</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if m[i,j]&lt;∞ then 
      return(m[i,j]);</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i=j the 
      m[i,j]:=0</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 
      </FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for 
      k:=i to j-1 do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      q:=LOOKUP_CHAIN(P,i.,k)+LOOKUP_CHAIN(P,k+1,j)+p<SUB>i-1</SUB>p<SUB>k</SUB>p<SUB>j</SUB>;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 
      q<M[I,J] then m[i,j]:="q;</DIV"> </FONT>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      return(m[i,j]);</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT></DIV>
      <DIV><FONT size=4>与动态规划算法MATRIX_CHAIN_ORDER一样，备忘录算法MEMOIZED_ 
      MATRIX_CHAIN用数组m[1…n,1…n]的单元m[i,j]来记录解子问题A<SUB>i…j</SUB>的最优计算量。M[i,j]初始化为∞，表示相应于A<SUB>i…j</SUB>的子问题还未被计算。在调用LOODKUP 
      _CHAIN(P,i,j)时，若m[i,j]&lt;∞，则表示m[i,j]中存储的是所要求子问题的计算结果，直接返回此结果即可。否则与直接递归算法一样，自顶向下地递归计算，并将计算结果存入m[i,j]后返回。因此，LOODKUP_CHAIN(P,i,j)总能正确返回m[i,j]的值，但仅在它第一次被调用时计算，以后的调用就直接返回计算结果。</FONT></DIV>
      <DIV><FONT 
      size=4>与动态规划算法一样，备忘录算法MEMOIZED_MATRIX_CHAIN耗时O(n<SUP>3</SUP>)。事实上，共有O(n<SUP>2</SUP>)个备忘记录项m[i,j]，i=1,2,…,n 
      , 
      j=i,i+1,…n，这些记录项的初始化耗费O(n<SUP>2</SUP>)时间。每个记录项只填入一次，每次填入时，不包括填入其他记录项的时间，共耗费O(n)。因此，LOODKUP_CHAIN(P,1,n)填入O(n<SUP>2</SUP>)个记录项总共耗费O(n<SUP>3</SUP>)计算时间。由此可见，通过使用备忘录技术，直接递归算法的计算时间从仍Ω(2<SUP>n</SUP>)降至O(n<SUP>3</SUP>)。</FONT></DIV>
      <DIV><FONT 
      size=4>综上所述，矩阵连乘积的最优计算次序问题可用自顶向下的备忘录算法或自底向上的动态规划算法在O(n<SUP>3</SUP>)时间内求解。这两个算法都利用了子问题重叠性质。总共有θ(n<SUP>2</SUP>)个不同的子问题。对每个子问题，两种方法都只解一次，并记录答案，再碰到该问题时，不重新求解而简单地取用已得到的答案。因此，节省了计算量，提高了算法的效率。</FONT></DIV>
      <DIV><FONT 
      size=4>一般地讲，当一个问题的所有子问题都至少要解一次时，用动态规划算法解比用备忘录方法好。此时，动态规划算法没有任何多余的计算。同时，对于许多问题，常可利用其规则的表格存取方式，来减少在动态规划算法中的计算时间和空间需求。当子问题空间中的部分子问题可不必求解时，用备忘录方法则较有利，因为从其控制结构可以看出，该方法只解那些确实需要求解的子问题。</FONT></DIV>
      <DIV>
      <DIV><FONT size=4><B>例</B><B>3&nbsp; 
      </B><B>最长公共子序列问题</B><B>LCS</B></FONT></DIV>
      <DIV><FONT size=4><B>问题描述</B><B>&nbsp;&nbsp; 
      </B>一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列<I>X</I>=&lt;<I>x</I><SUB>1</SUB>, 
      <I>x</I><SUB>2</SUB>,…, 
      <I>x</I><SUB>m</SUB>&gt;，则另一序列<I>Z</I>=&lt;<I>z</I><SUB>1</SUB>, 
      <I>z</I><SUB>2</SUB>,…, 
      <I>z</I><SUB>k</SUB>&gt;是<I>X</I>的子序列是指存在一个严格递增的下标序列 
      &lt;<I>i</I><SUB>1</SUB>, <I>i</I><SUB>2</SUB>,…, 
      <I>i</I><SUB>k</SUB>&gt;，使得对于所有<I>j</I>=1,2,…,k有</FONT></DIV>
      <DIV><SUB><FONT size=4></FONT></SUB></DIV>
      <DIV><FONT 
      size=4>例如，序列<I>Z</I>=<B,C,D,B>是序列<I>X</I>=<A,B,C,B,D,A,B>的子序列，相应的递增下标序列为&lt;2,3,5,7&gt;。</FONT></DIV>
      <DIV><FONT 
      size=4>给定两个序列<I>X</I>和<I>Y</I>，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例如，若X=<A, 
      C, B, D, A, B>和Y=<B, C, B, D, A, A>，则序列<B, C, A>是X和Y的一个公共子序列，序列<B, C, B, 
      A>也是X和Y的一个公共子序列。而且，后者是X和Y的一个最长公共子序列，因为X和Y没有长度大于4的公共子序列。</FONT></DIV>
      <DIV><FONT size=4>最长公共子序列(LCS)问题：给定两个序列X=&lt;<I>x</I><SUB>1</SUB>, 
      <I>x</I><SUB>2</SUB>, …, 
      <I>x</I><SUB>m</SUB>&gt;和Y=&lt;<I>y</I><SUB>1</SUB>, <I>y</I><SUB>2</SUB>, 
      … , <I>y</I><SUB>n</SUB>&gt;，要求找出X和Y的一个最长公共子序列。</FONT></DIV>
      <DIV><B><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/LCS/solution.htm"><FONT 
      face=宋体 size=4>参考解答</FONT></A><FONT size=4>&nbsp;&nbsp; </FONT></B><FONT 
      size=4>动态规划算法可有效地解此问题。下面我们按照动态规划算法设计的各个步骤来设计一个解此问题的有效, 算法。</FONT></DIV>
      <DIV><FONT size=4>1.最长公共子序列的结构</FONT></DIV>
      <DIV><FONT 
      size=4>解最长公共子序列问题时最容易想到的算法是穷举搜索法，即对X的每一个子序列，检查它是否也是Y的子序列，从而确定它是否为X和Y的公共子序列，并且在检查过程中选出最长的公共子序列。X的所有子序列都检查过后即可求出X和Y的最长公共子序列。X的一个子序列相应于下标序列{1, 
      2, …, m}的一个子序列，因此，X共有2<SUP>m</SUP>个不同子序列，从而穷举搜索法需要指数时间。</FONT></DIV>
      <DIV><FONT size=4>事实上，最长公共子序列问题也有最优子结构性质，因为我们有如下定理：</FONT></DIV>
      <DIV><FONT size=4><B>定理</B><B>: </B></FONT><A name=th></A><FONT 
      size=4>LCS的最优子结构性质</FONT></DIV>
      <DIV><FONT size=4>设序列X=<X<SUB>1</SUB>, x<SUB>2</SUB>, …, 
      x<SUB>m</SUB>&gt;和Y=<Y<SUB>1</SUB>, y<SUB>2</SUB>, …, 
      y<SUB>n</SUB>&gt;的一个最长公共子序列Z=<Z<SUB>1</SUB>, z<SUB>2</SUB>, …, 
      z<SUB>k</SUB>&gt;，则：</FONT></DIV>
      <DIV><FONT 
      size=4>若x<SUB>m</SUB>=y<SUB>n</SUB>，则z<SUB>k</SUB>=x<SUB>m</SUB>=y<SUB>n</SUB>且Z<SUB>k-1</SUB>是X<SUB>m-1</SUB>和Y<SUB>n-1</SUB>的最长公共子序列； 
      </FONT></DIV>
      <DIV><FONT size=4>若x<SUB>m</SUB>≠y<SUB>n</SUB>且z<SUB>k</SUB>≠x<SUB>m 
      </SUB><SUB>，</SUB>则Z是X<SUB>m-1</SUB>和Y的最长公共子序列； </FONT></DIV>
      <DIV><FONT size=4>若x<SUB>m</SUB>≠y<SUB>n</SUB>且z<SUB>k</SUB>≠y<SUB>n</SUB> 
      ，则Z是X和Y<SUB>n-1</SUB>的最长公共子序列。 </FONT></DIV>
      <DIV><FONT size=4>其中X<SUB>m-1</SUB>=<X<SUB>1</SUB>, x<SUB>2</SUB>, …, 
      x<SUB>m-1</SUB>&gt;，Y<SUB>n-1</SUB>=<Y<SUB>1</SUB>, y<SUB>2</SUB>, …, 
      y<SUB>n-1</SUB>&gt;，Z<SUB>k-1</SUB>=<Z<SUB>1</SUB>, z<SUB>2</SUB>, …, 
      z<SUB>k-1</SUB>&gt;。</FONT></DIV>
      <DIV><FONT size=4><B>证明</B><B>&nbsp;&nbsp; 
      </B>用反证法。若z<SUB>k</SUB>≠x<SUB>m</SUB>，则<Z<SUB>1</SUB>, z<SUB>2</SUB>, …, 
      z<SUB>k </SUB>,x<SUB>m 
      </SUB>&gt;是X和Y的长度为k十1的公共子序列。这与Z是X和Y的一个最长公共子序列矛盾。因此，必有z<SUB>k</SUB>=x<SUB>m</SUB>=y<SUB>n</SUB>。由此可知Z<SUB>k-1</SUB>是X<SUB>m-1</SUB>和Y<SUB>n-1</SUB>的一个长度为k-1的公共子序列。若X<SUB>m-1</SUB>和Y<SUB>n-1</SUB>有一个长度大于k-1的公共子序列W，则将x<SUB>m</SUB>加在其尾部将产生X和Y的一个长度大于k的公共子序列。此为矛盾。故Z<SUB>k-1</SUB>是X<SUB>m-1</SUB>和Y<SUB>n-1</SUB>的一个最长公共子序列。 
      </FONT></DIV>
      <DIV><FONT 
      size=4>由于z<SUB>k</SUB>≠x<SUB>m</SUB>，Z是X<SUB>m-1</SUB>和Y的一个公共子序列。若X<SUB>m-1</SUB>和Y有一个长度大于k的公共子序列W，则W也是X和Y的一个长度大于k的公共子序列。这与Z是X和Y的一个最长公共子序列矛盾。由此即知Z是X<SUB>m-1</SUB>和Y的一个最长公共子序列。 
      </FONT></DIV>
      <DIV><FONT size=4>与 2.类似。 </FONT></DIV>
      <DIV><FONT 
      size=4>这个定理告诉我们，两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter3.htm#optimality"><FONT 
      face=宋体 size=4>最优子结构性质</FONT></A><FONT size=4>。</FONT></DIV>
      <DIV><FONT size=4>2.子问题的递归结构</FONT></DIV>
      <DIV><FONT size=4>由最长公共子序列问题的最优子结构性质可知，要找出X=<X<SUB>1</SUB>, x<SUB>2</SUB>, 
      …, x<SUB>m</SUB>&gt;和Y=<Y<SUB>1</SUB>, y<SUB>2</SUB>, …, 
      y<SUB>n</SUB>&gt;的最长公共子序列，可按以下方式递归地进行：当x<SUB>m</SUB>=y<SUB>n</SUB>时，找出X<SUB>m-1</SUB>和Y<SUB>n-1</SUB>的最长公共子序列，然后在其尾部加上x<SUB>m</SUB>(=y<SUB>n</SUB>)即可得X和Y的一个最长公共子序列。当x<SUB>m</SUB>≠y<SUB>n</SUB>时，必须解两个子问题，即找出X<SUB>m-1</SUB>和Y的一个最长公共子序列及X和Y<SUB>n-1</SUB>的一个最长公共子序列。这两个公共子序列中较长者即为X和Y的一个最长公共子序列。</FONT></DIV>
      <DIV><FONT size=4>由此递归结构容易看到最长公共子序列问题具有</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter3.htm#repeate"><FONT 
      face=宋体 size=4>子问题重叠性质</FONT></A><FONT 
      size=4>。例如，在计算X和Y的最长公共子序列时，可能要计算出X和Y<SUB>n-1</SUB>及X<SUB>m-1</SUB>和Y的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算X<SUB>m-1</SUB>和Y<SUB>n-1</SUB>的最长公共子序列。</FONT></DIV>
      <DIV><FONT 
      size=4>与矩阵连乘积最优计算次序问题类似，我们来建立子问题的最优值的递归关系。用c[i,j]记录序列X<SUB>i</SUB>和Y<SUB>j</SUB>的最长公共子序列的长度。其中X<SUB>i</SUB>=<X<SUB>1</SUB>, 
      x<SUB>2</SUB>, …, x<SUB>i</SUB>&gt;，Y<SUB>j</SUB>=<Y<SUB>1</SUB>, 
      y<SUB>2</SUB>, …, 
      y<SUB>j</SUB>&gt;。当i=0或j=0时，空序列是X<SUB>i</SUB>和Y<SUB>j</SUB>的最长公共子序列，故c[i,j]=0。其他情况下，由</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/LCS/solution.htm#th#th"><FONT 
      face=宋体 size=4>定理</FONT></A><FONT size=4>可建立递归关系如下：</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435370.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>3.计算最优值</FONT></DIV>
      <DIV><FONT 
      size=4>直接利用(2.2)式容易写出一个计算c[i,j]的递归算法，但其计算时间是随输入长度指数增长的。由于在所考虑的子问题空间中，总共只有<I>θ</I>(<I>m*n</I>)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。</FONT></DIV>
      <DIV><FONT size=4>计算最长公共子序列长度的动态规划算法LCS_LENGTH(X,Y)以序列X=<X<SUB>1</SUB>, 
      x<SUB>2</SUB>, …, x<SUB>m</SUB>&gt;和Y=<Y<SUB>1</SUB>, y<SUB>2</SUB>, …, 
      y<SUB>n</SUB>&gt;作为输入。输出两个数组c[0..m ,0..n]和b[1..m 
      ,1..n]。其中c[i,j]存储X<SUB>i</SUB>与Y<SUB>j</SUB>的最长公共子序列的长度，b[i,j]记录指示c[i,j]的值是由哪一个子问题的解达到的，这在构造最长公共子序列时要用到。最后，X和Y的最长公共子序列的长度记录于c[m,n]中。</FONT></DIV>
      <DIV><FONT size=4>Procedure LCS_LENGTH(X,Y);</FONT></DIV>
      <DIV><FONT size=4>begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp; m:=length[X];</FONT></DIV>
      <DIV><FONT size=4>&nbsp; n:=length[Y];</FONT></DIV>
      <DIV><FONT size=4>&nbsp; for i:=1 to m do c[i,j]:=0;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; for j:=1 to n do c[0,j]:=0;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; for i:=1 to m do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; for j:=1 to n do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if x[i]=y[j] 
      then</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      c[i,j]:=c[i-1,j-1]+1;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      b[i,j]:="I";</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if c[i-1,j]≥c[i,j-1] 
      then</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      c[i,j]:=c[i-1,j];</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      b[i,j]:="↑";</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      c[i,j]:=c[i,j-1];</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      b[i,j]:="←"</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; return(c,b);</FONT></DIV>
      <DIV><FONT size=4>end;</FONT></DIV>
      <DIV><FONT 
      size=4>由于每个数组单元的计算耗费<I>Ο</I>(1)时间，算法LCS_LENGTH耗时<I>Ο</I>(<I>mn</I>)。</FONT></DIV>
      <DIV><FONT size=4>4.构造最长公共子序列</FONT></DIV>
      <DIV><FONT size=4>由算法LCS_LENGTH计算得到的数组b可用于快速构造序列X=<X<SUB>1</SUB>, 
      x<SUB>2</SUB>, …, x<SUB>m</SUB>&gt;和Y=<Y<SUB>1</SUB>, y<SUB>2</SUB>, …, 
      y<SUB>n</SUB>&gt;的最长公共子序列。首先从b[m,n]开始，沿着其中的箭头所指的方向在数组b中搜索。当b[i,j]中遇到"I"时，表示X<SUB>i</SUB>与Y<SUB>j</SUB>的最长公共子序列是由X<SUB>i-1</SUB>与Y<SUB>j-1</SUB>的最长公共子序列在尾部加上x<SUB>i</SUB>得到的子序列；当b[i,j]中遇到"↑"时，表示X<SUB>i</SUB>与Y<SUB>j</SUB>的最长公共子序列和X<SUB>i-1</SUB>与Y<SUB>j</SUB>的最长公共子序列相同；当b[i,j]中遇到"←"时，表示X<SUB>i</SUB>与Y<SUB>j</SUB>的最长公共子序列和X<SUB>i</SUB>与Y<SUB>j-1</SUB>的最长公共子序列相同。</FONT></DIV>
      <DIV><FONT 
      size=4>下面的算法LCS(b,X,i,j)实现根据b的内容打印出X<SUB>i</SUB>与Y<SUB>j</SUB>的最长公共子序列。通过算法的调用LCS(b,X,length[X],length[Y])，便可打印出序列X和Y的最长公共子序列。</FONT></DIV>
      <DIV><FONT size=4>Procedure LCS(b,X,i,j);</FONT></DIV>
      <DIV><FONT size=4>begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp; if i=0 or j=0 then return;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; if b[i,j]="I" then</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      LCS(b,X,i-1,j-1);</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(x[i]); 
      {打印x[i]}</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; end</FONT></DIV>
      <DIV><FONT size=4>&nbsp; else if b[i,j]="↑" then LCS(b,X,i-1,j) 
      </FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      else LCS(b,X,i,j-1);</FONT></DIV>
      <DIV><FONT size=4>end; </FONT></DIV>
      <DIV><FONT 
      size=4>在算法LCS中，每一次的递归调用使i或j减1，因此算法的计算时间为<I>O</I>(m+n)。</FONT></DIV>
      <DIV><FONT 
      size=4>例如，设所给的两个序列为X=<A，B，C，B，D，A，B>和Y=<B，D，C，A，B，A>。由算法LCS_LENGTH和LCS计算出的结果如图2所示。</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435330.htm" 
      border=0></FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435688.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>图2&nbsp;&nbsp; 算法LCS的计算结果</FONT></DIV>
      <DIV><FONT size=4>5.算法的改进</FONT></DIV>
      <DIV><FONT 
      size=4>对于一个具体问题，按照一般的算法设计策略设计出的算法，往往在算法的时间和空间需求上还可以改进。这种改进，通常是利用具体问题的一些特殊性。</FONT></DIV>
      <DIV><FONT 
      size=4>例如，在算法LCS_LENGTH和LCS中，可进一步将数组b省去。事实上，数组元素c[i,j]的值仅由c[i-1,j-1]，c[i-1,j]和c[i,j-1]三个值之一确定，而数组元素b[i,j]也只是用来指示c[i,j]究竟由哪个值确定。因此，在算法LCS中，我们可以不借助于数组b而借助于数组c本身临时判断c[i,j]的值是由c[i-1,j-1]，c[i-1,j]和c[i,j-1]中哪一个数值元素所确定，代价是<I>Ο</I>(1)时间。既然b对于算法LCS不是必要的，那么算法LCS_LENGTH便不必保存它。这一来，可节省<I>θ</I>(mn)的空间，而LCS_LENGTH和LCS所需要的时间分别仍然是<I>Ο</I>(mn)和<I>Ο</I>(m+n)。不过，由于数组c仍需要<I>Ο</I>(mn)的空间，因此这里所作的改进，只是在空间复杂性的常数因子上的改进。</FONT></DIV>
      <DIV><FONT 
      size=4>另外，如果只需要计算最长公共子序列的长度，则算法的空间需求还可大大减少。事实上，在计算c[i,j]时，只用到数组c的第i行和第i-1行。因此，只要用2行的数组空间就可以计算出最长公共子序列的长度。更进一步的分析还可将空间需求减至min(m, 
      n)。</FONT></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4><B>例</B><B>4&nbsp; 
      </B><B>凸多边形的最优三角剖分问题</B><B></B></FONT></DIV>
      <DIV><FONT size=4>问题描述</FONT></DIV>
      <DIV><FONT size=4><B><I>&nbsp;&nbsp;&nbsp; 
      </I></B><I>多边形</I>是平面上一条分段线性的闭曲线。也就是说，多边形是由一系列首尾相接的直线段组成的。组成多边形的各直线段称为该多边形的边。多边形相接两条边的连接点称为多边形的顶点。若多边形的边之间除了连接顶点外没有别的公共点，则称该多边形为<I>简单多边形</I>。一个简单多边形将平面分为3个部分：被包围在多边形内的所有点构成了多边形的内部；多边形本身构成多边形的边界；而平面上其余的点构成了多边形的外部。当一个简单多边形及其内部构成一个闭凸集时，称该简单多边形为<I>凸多边形</I>。也就是说凸多边形边界上或内部的任意两点所连成的直线段上所有的点均在该凸多边形的内部或边界上。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 通常，用多边形顶点的逆时针序列来表示一个凸多边形，即P=<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… 
      ,v<SUB>n-1</SUB>&gt;表示具有n条边v<SUB>0</SUB>v<SUB>1</SUB>，v<SUB>1</SUB>v<SUB>2</SUB>，… 
      ,v<SUB>n-1</SUB>v<SUB>n</SUB>的一个凸多边形，其中，约定v<SUB>0</SUB>=v<SUB>n 
      </SUB><SUB>。</SUB></FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      若v<SUB>i</SUB>与v<SUB>j</SUB>是多边形上不相邻的两个顶点，则线段v<SUB>i</SUB>v<SUB>j</SUB>称为多边形的一条弦。弦 
      将多边形分割成凸的两个子多边形<V<SUB>i </SUB>,v<SUB>i+1 </SUB>,… 
      ,v<SUB>j</SUB>&gt;和<V<SUB>j </SUB,>,v<SUB>j+1 </SUB>,… 
      ,v<SUB>i</SUB>&gt;。多边形的三角剖分是一个将多边形分割成互不重迭的三角形的弦的集合T。图1是一个凸多边形的两个不同的三角剖分。</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435444.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>图1 一个凸多边形的2个不同的三角剖分</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      在凸多边形P的一个三角剖分T中，各弦互不相交且弦数已达到最大，即P的任一不在T中的弦必与T中某一弦相交。在一个有n个顶点的凸多边形的三角刮分中，恰好有n-3条弦和n-2个三角形。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 凸多边形最优三角剖分的问题是：给定一个凸多边形P=<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… 
      ,v<SUB>n-1</SUB>&gt;以及定义在由多边形的边和弦组成的三角形上的权函数<I>ω</I>。要求确定该凸多边形的一个三角剖分，使得该三角剖分对应的权即剖分中诸三角形上的权之和为最小。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 可以定义三角形上各种各样的权函数W。例如：定义&nbsp; 
      <I>ω</I>(△v<SUB>i</SUB>v<SUB>j</SUB>v<SUB>k</SUB>)=|v<SUB>i</SUB>v<SUB>j</SUB>|+|v<SUB>i</SUB>v<SUB>k</SUB>|+|v<SUB>k</SUB>v<SUB>j</SUB>|,其中，|v<SUB>i</SUB>v<SUB>j</SUB>|是点v<SUB>i</SUB>到v<SUB>j</SUB>的欧氏距离。相应于此权函数的最优三角剖分即为最小弦长三角剖分。</FONT></DIV>
      <DIV><FONT size=4><B>注意：</B>解决此问题的算法必须适用于<B>任意</B>的权函数。</FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/polygon/solution.htm"><FONT 
      face=宋体 size=4>参考解答</FONT></A></DIV>
      <DIV><FONT 
      size=4>用动态规划算法也能有效地求解凸多边形的最优三角剖分问题。尽管这是一个计算几何学问题，但在本质上，它与</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/problem.htm"><FONT 
      face=宋体 size=4>矩阵连乘积的最优计算次序问题</FONT></A><FONT size=4>极为相似。</FONT></DIV>
      <DIV><FONT size=4>1.三角剖分的结构及其相关问题</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      凸多边形的三角剖分与表达式的完全加括号方式之间具有十分紧密的联系。正如所看到过的，矩阵连乘积的最优计算次序问题等价于矩阵链的完全加括号方式。这些问题之间的相关性可从它们所对应的完全二叉树的同构性看出。这里的所谓<I>完全二叉树</I>是指叶结点以外的所有结点的度数都为2的二叉树(注意与<I>满二叉树</I>和<I>近似满二叉树</I>的区别)。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      一个表达式的完全加括号方式对应于一棵完全二叉树，人们称这棵二叉树为表达式的语法树。例如，与完全加括号的矩阵连乘积((A<SUB>1</SUB>(A<SUB>2</SUB>A<SUB>3</SUB>))(A<SUB>4</SUB>(A<SUB>5</SUB>A<SUB>6</SUB>)))相对应的语法树如图3(a)所示。</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435346.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>图3&nbsp;&nbsp;&nbsp; 表达式语法树与三角剖分的对应</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      语法树中每一个叶子表示表达式中一个原子。在语法树中，若一结点有一个表示表达式E<SUB>1</SUB>的左子树，以及一个表示表达式E<SUB>r</SUB>的右子树，则以该结点为根的子树表示表达式(E<SUB>1</SUB>E<SUB>r</SUB>)。因此，有n个原子的完全加括号表达式对应于唯一的一棵有n个叶结点的语法树，反之亦然。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 凸多边形<V<SUB>0 </SUB>,v<SUB>1 </SUB>,… 
      ,v<SUB>n-1</SUB>&gt;的三角剖分也可以用语法树来表示。例如，图3(a)中凸多边形的三角剖分可用图3(b)所示的语法树来表示。该语法树的根结点为边v<SUB>0</SUB>v<SUB>6</SUB>，三角剖分中的弦组成其余的内部结点。多边形中除v<SUB>0</SUB>v<SUB>6</SUB>边外的每一条边是语法树的一个叶结点。树根v<SUB>0</SUB>v<SUB>6</SUB>是三角形v<SUB>0</SUB>v<SUB>3</SUB>v<SUB>6</SUB>的一条边，该三角形将原多边形分为3个部分：三角形v<SUB>0</SUB>v<SUB>3</SUB>v<SUB>6</SUB>，凸多边形<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… ,v<SUB>3</SUB>&gt;和凸多边形<V<SUB>3 </SUB>,v<SUB>4 
      </SUB>,… 
      ,v<SUB>6</SUB>&gt;。三角形v<SUB>0</SUB>v<SUB>3</SUB>v<SUB>6</SUB>的另外两条边，即弦v<SUB>3</SUB>v<SUB>6</SUB>和v<SUB>0</SUB>v<SUB>3</SUB>为根的两个儿子。以它们为根的子树分别表示凸多边形<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… ,v<SUB>3</SUB>&gt;和凸多边形<V<SUB>3 </SUB>,v<SUB>4 
      </SUB>,… ,v<SUB>6</SUB>&gt;的三角剖分。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      在一般情况下，一个凸n边形的三角剖分对应于一棵有n-1个叶子的语法树。反之，也可根据一棵有n-1个叶子的语法树产生相应的一个凸n边形的三角剖分。也就是说，凸n边形的三角剖分与n-1个叶子的语法树之间存在一一对应关系。由于n个矩阵的完全加括号乘积与n个叶子的语法树之间存在一一对应关系，因此n个矩阵的完全加括号乘积也与凸(n+1)边形的三角剖分之间存在一一对应关系。图3的(a)和(b)表示出了这种对应关系，这时n=6。矩阵连乘积A<SUB>1</SUB>A<SUB>2</SUB>..A<SUB>6</SUB>中的每个矩阵A<SUB>i</SUB>对应于凸(n+1)边形中的一条边v<SUB>i-1</SUB>v<SUB>i</SUB>。三角剖分中的一条弦v<SUB>i</SUB>v<SUB>j</SUB>，i<J-1，对应于矩阵连乘积A<SUB>i+1..j</SUB> 
      。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      事实上，矩阵连乘积的最优计算次序问题是凸多边形最优三角剖分问题的一个特殊情形。&nbsp;对于给定的矩阵链A<SUB>1</SUB>A<SUB>2</SUB>..A<SUB>n</SUB>，定义一个与之相应的凸(n+1)边形P=<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… 
      ,v<SUB>n</SUB>&gt;，使得矩阵A<SUB>i</SUB>与凸多边形的边v<SUB>i-1</SUB>v<SUB>i</SUB>一一对应。若矩阵A<SUB>i</SUB>的维数为p<SUB>i-1</SUB>×p<SUB>i</SUB>,i=1,2,…,n，则定义三角形v<SUB>i</SUB>v<SUB>j</SUB>v<SUB>k</SUB>上的权函数值为： 
      <I>ω</I>(△v<SUB>i</SUB>v<SUB>j</SUB>v<SUB>k</SUB>)=p<SUB>i</SUB>p<SUB>j</SUB>p<SUB>k</SUB>。依此权函数的定义，凸多边形P的最优三角剖分所对应的语法树给出矩阵链A<SUB>1</SUB>A<SUB>2</SUB>..A<SUB>n</SUB>的最优完全加括号方式。</FONT></DIV>
      <DIV><FONT size=4>2.最优子结构性质</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      凸多边形的最优三角剖分问题有最优子结构性质。事实上，若凸(n+1)边形P=<V<SUB>0 </SUB>,v<SUB>1 </SUB>,… 
      ,v<SUB>n</SUB>&gt;的一个最优三角剖分T包含三角形v<SUB>0</SUB>v<SUB>k</SUB>v<SUB>n 
      </SUB><SUB>，</SUB><SUB> 
      </SUB>1≤k≤n-1，则T的权为3个部分权的和，即三角形v<SUB>0</SUB>v<SUB>k</SUB>v<SUB>n</SUB>的权，子多边形<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… ,v<SUB>k</SUB>&gt;的权和<V<SUB>k </SUB>,v<SUB>k+1 
      </SUB>,… ,v<SUB>n</SUB>&gt;的权之和。可以断言由T所确定的这两个子多边形的三角剖分也是最优的，因为若有<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… ,v<SUB>k</SUB>&gt;或<V<SUB>k </SUB>,v<SUB>k+1 
      </SUB>,… ,v<SUB>n</SUB>&gt;的更小权的三角剖分，将会导致T不是最优三角剖分的矛盾。</FONT></DIV>
      <DIV><FONT size=4>3.最优三角剖分对应的权的递归结构</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 首先，定义t[i,j]，1≤i<J≤N，为凸子多边形<V<SUB>i-1 
      </SUB>,v<SUB>i </SUB>,… 
      ,v<SUB>j</SUB>&gt;的最优三角剖分所对应的权值，即最优值。为方便起见，设退化的多边形<V<SUB>i-1</SUB> 
      ,v<SUB>i</SUB>&gt;具有权值0。据此定义，要计算的凸(n+1)边多边形P对应的权的最优值为t[1,n]。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      t[i,j]的值可以利用最优子结构性质递归地计算。由于退化的2顶点多边形的权值为0，所以t[i,i]=0，i=1,2,…,n 
      。当j一i≥1时，子多边形<V<SUB>i-1 </SUB>,v<SUB>i </SUB>,… 
      ,v<SUB>j</SUB>&gt;至少有3个顶点。由最优于结构性质,t[i,j]的值应为t[i,k]的值加上t[k+1,j]的值，再加上△v<SUB>i-1</SUB>v<SUB>k</SUB>v<SUB>j</SUB>的权值，并在i≤k≤j-1的范围内取最小。由此，t[i,j]可递归地定义为：</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435795.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>4.计算最优值</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 将(2.3)式与</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#f2-1"><FONT 
      face=宋体 size=4>矩阵连乘积的最优计算次序问题中计算m[i,j]的(2.l)式</FONT></A><FONT 
      size=4>进行比较容易看出，除了权函数的定义外，两个递归式是完全一样的。因此只要对计算m[i,j]的</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#MATRIX_CHAIN_ORDER"><FONT 
      face=宋体 size=4>算法MATRIX_CHAIN_ORDER</FONT></A><FONT 
      size=4>做很小的修改就完全适用于计算t[i,j]。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 下面描述的计算凸(n+1)边形P=<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… 
      ,v<SUB>n</SUB>&gt;的三角剖分最优权值的动态规划算法MINIMUM_WEIGHT_TRIANGULATION，输入是凸多边形P=<V<SUB>0 
      </SUB>,v<SUB>1 </SUB>,… 
      ,v<SUB>n</SUB>&gt;的权函数<I>ω</I>，输出是最优值t[i,j]和使得t[i,k]+t[k+1,j]+<I>ω</I>(△v<SUB>i-1</SUB>v<SUB>k</SUB>v<SUB>j</SUB>)达到最优的位置(k=)s[i,j]，1≤i≤j≤n 
      。</FONT></DIV>
      <DIV><FONT size=4>Procedure 
MINIMUM_WEIGHT_TRIANGULATION(P,w)；</FONT></DIV>
      <DIV><FONT size=4>begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp; n:=length[p]-1;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; for i:=1 to n do t[i,i]:=0;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; for ll:=2 to n do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i:=1 to n-ll+1 
      do</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      j:=i+ll-1;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      t[i,j]:=∞;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      for k:=i to j-1 do</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      q:=t[i,k]+t[k+1,j]+ω(△vi-1vkvj);</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      if q<T[I,J] DIV then<> </FONT>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      begin</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      t[i,j]:=q;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      s[i,j]:=k;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end;</FONT></DIV>
      <DIV><FONT 
      size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end;</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      end;</FONT></DIV>
      <DIV><FONT size=4>&nbsp; return(t,s);</FONT></DIV>
      <DIV><FONT size=4>end;</FONT></DIV>
      <DIV><FONT size=4>与</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/matrix_chain_mul/solution.htm#MATRIX_CHAIN_ORDER"><FONT 
      face=宋体 size=4>MATRIX_CHAIN_ORDER</FONT></A><FONT 
      size=4>一样，算法MINIMUM_WEIGHT_TRIANGULATION占用<I>θ</I>(n<SUP>2</SUP>)空间，耗时<I>θ</I>(n<SUP>3</SUP>)。</FONT></DIV>
      <DIV><FONT size=4>5.构造最优三角剖分</FONT></DIV>
      <DIV><FONT size=4>如我们所看到的，对于任意的1≤i≤j≤n 
      ，算法MINIMUM_WEIGHT_TRIANGULATION在计算每一个子多边形<V<SUB>i-1 </SUB>,v<SUB>i 
      </SUB>,… 
      ,v<SUB>j</SUB>&gt;的最优三角剖分所对应的权值t[i,j]的同时，还在s[i,j]中记录了此最优三角剖分中与边(或弦)v<SUB>i-1</SUB>v<SUB>j</SUB>构成的三角形的第三个顶点的位置。因此，利用最优子结构性质并借助于s[i,j]，1≤i≤j≤n 
      ，凸(n+l)边形P=<V<SUB>0 </SUB>,v<SUB>1 </SUB>,… 
      ,v<SUB>n</SUB>&gt;的最优三角剖分可容易地在<I>Ο</I>(n)时间内构造出来。</FONT></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4><B>例</B><B>5&nbsp; </B><B>多边形计算</B><B> (<A 
      href="http://algorithm.diy.myrice.com/contest/IOI/problems/IOI1998/index.htm"><FONT 
      face=宋体 size=2>IOI'98</FONT></A>)</B></FONT></DIV>
      <DIV><FONT size=4>问题描述</FONT></DIV>
      <DIV><FONT size=4>Polygon is a game for one player that starts on a 
      polygon with <B>N</B> vertices, like the one in Figure 1, where 
      <B>N</B>=4. Each vertex is labelled with an integer and each edge is 
      labelled with either the symbol + (addition) or the symbol * (product). 
      The edges are numbered from 1 to <B>N</B>. </FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435645.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4><I>Figure 1. Graphical representation of a polygon</I> 
      </FONT></DIV>
      <DIV><FONT size=4>On the <B>first move</B>, one of the edges is removed. 
      </FONT></DIV>
      <DIV><FONT size=4>Subsequent moves involve the following steps: 
      </FONT></DIV>
      <DIV><FONT size=4>pick an edge <B>E</B> and the two vertices <B>V_1</B> 
      and <B>V_2</B> that are linked by <B>E</B>; and </FONT></DIV>
      <DIV><FONT size=4>replace them by a new vertex, labelled with the result 
      of performing the operation indicated in <B>E</B> on the labels of 
      <B>V_1</B> and <B>V_2</B>. </FONT></DIV>
      <DIV><FONT size=4>The game ends when there are no more edges, and its 
      score is the label of the single vertex remaining. </FONT></DIV>
      <DIV><FONT size=4>Sample game</FONT></DIV>
      <DIV><FONT size=4>Consider the polygon of Figure 1. The player started by 
      removing edge 3. The effects are depicted in Figure 2. </FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435881.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>Task</FONT></DIV>
      <DIV><FONT size=4>Write a program that, given a polygon, computes the 
      highest possible score and lists all the edges that, if removed on the 
      first move, can lead to a game with that score. </FONT></DIV>
      <DIV><FONT size=4>Input Data</FONT></DIV>
      <DIV><FONT size=4>File <CODE>POLYGON.IN</CODE> describes a polygon with 
      <B>N</B> vertices. It contains two lines.</FONT></DIV>
      <DIV><FONT size=4>On the first line is the number <B>N</B>.</FONT></DIV>
      <DIV><FONT size=4>The second line contains the labels of edges 1, ..., 
      <B>N</B>, interleaved with the vertices' labels (first that of the vertex 
      between edges 1 and 2, then that of the vertex between edges 2 and 3, and 
      so on, until that of the vertex between edges <B>N</B> and 1), all 
      separated by one space. An edge label is either the letter <I>t</I> 
      (representing +) or the letter <I>x</I> (representing *). </FONT></DIV>
      <DIV><FONT size=4>Sample Input</FONT></DIV>
      <DIV><CODE><FONT size=4>4</FONT></CODE></DIV>
      <DIV><CODE><FONT size=4>t -7 t 4 x 2 x 5</FONT></CODE></DIV>
      <DIV><FONT size=4>This is the input file for the polygon of Figure 1. The 
      second line starts with the label of edge 1. </FONT></DIV>
      <DIV><FONT size=4>Output Data</FONT></DIV>
      <DIV><FONT size=4>On the first line of file <CODE>POLYGON.OUT</CODE> your 
      program must write the highest score one can get for the input 
      polygon.</FONT></DIV>
      <DIV><FONT size=4>On the second line it must write the list of all edges 
      that, if removed on the first move, can lead to a game with that 
      score.</FONT></DIV>
      <DIV><FONT size=4>Edges must be written in increasing order, separated by 
      one space. </FONT></DIV>
      <DIV><FONT size=4>Sample Output</FONT></DIV>
      <DIV><CODE><FONT size=4>33</FONT></CODE></DIV>
      <DIV><CODE><FONT size=4>1 2</FONT></CODE></DIV>
      <DIV><FONT size=4>This must be the output file for the polygon of Figure 
      1. </FONT></DIV>
      <DIV><FONT size=4>Constraints</FONT></DIV>
      <DIV><FONT size=4>3 &lt;= N &lt;= 50</FONT></DIV>
      <DIV><FONT size=4>For any sequence of moves, vertex labels are in the 
      range [-32768,32767].</FONT></DIV>
      <DIV><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/polygon_cal/solution.htm"><FONT 
      face=宋体 size=4>参考解答</FONT></A></DIV>
      <DIV><FONT size=4>如果穷举解决此问题复杂性是n!，显然不可行。此问题看上去复杂，但是可以用</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/index.htm"><FONT 
      face=宋体 size=4>动态规划</FONT></A><FONT size=4>很好地解决。</FONT></DIV>
      <DIV><FONT size=4>这个问题看上去好像不具有</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter3.htm"><FONT 
      face=宋体 size=4>最优子结构</FONT></A><FONT 
      size=4>，但是仔细分析一下还是可以利用动态规划的思想解决的。关键在于乘法运算同号得正，异号得负，如果a,b都是负数，a*b有可能得到一个很大的正数。因此需要同时保存子问题的最大值和最小值。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 
      以节点i为首按顺时针长度为L的链的计算结果最小值为F<SUB>min</SUB>(i,L)，最大值为F<SUB>max</SUB>(i,L)，联结第i个节点和其顺时针方向的下一个节点(i 
      mod n)+1的边上的运算符记为opr(i)，则可以得到以下递归公式：</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435831.htm" 
      border=0></FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435980.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>公式中(i+t)mod n +1 
      是节点i顺时针方向的第t+1个节点的编号，V(i)为节点i上标的数字，opr(i)为联结第i个节点和其顺时针方向的下一个节点(i mod 
      n)+1的边上的运算符。根据这个公式，我们可以递推求出所有的F(i,n),i=1,2,..,n，其中的最大值就是所求。</FONT></DIV>
      <DIV><FONT size=4>&nbsp;&nbsp;&nbsp; 这道题已经不是很标准的动态规划了，但是它利用了</FONT><A 
      href="http://algorithm.diy.myrice.com/algorithm/technique/dynamic_programming/chapter4.htm"><FONT 
      face=宋体 size=4>动态规划的基本思想，分治和解决冗余</FONT></A><FONT size=4>。</FONT></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4><B>例</B><B>6&nbsp; </B><B>字符识别</B><B> (<A 
      href="http://algorithm.diy.myrice.com/contest/index.html?IOI/problems/IOI1997/index.htm" 
      target=_top><FONT face=宋体 size=2>IOI'97</FONT></A>)</B></FONT></DIV>
      <DIV><FONT size=4>问题描述 （</FONT><A 
      href="http://algorithm.diy.myrice.com/contest/index.html?IOI/problems/IOI1997/IOI97_Day_2_Tasks.htm" 
      target=_top><FONT face=宋体 size=4>英文原题</FONT></A><FONT 
size=4>）</FONT></DIV>
      <DIV><FONT size=4>这个题目需要你编写一个字符识别程序。</FONT></DIV>
      <DIV><FONT size=4>具体内容</FONT></DIV>
      <DIV><FONT size=4>每一个假设的字符图像(字符点阵)有20行，每行有20个"0"或"1"的数字。</FONT></DIV>
      <DIV><FONT size=4>FONT.DAT文件中有27个按照下列顺序排列的字符图像：</FONT></DIV>
      <DIV><FONT size=4>□abcdefghijklmnopqrstuvwxyz</FONT></DIV>
      <DIV><FONT size=4>□在这里表示空格符。</FONT></DIV>
      <DIV><FONT 
      size=4>文件IMAGE.DAT包含有一个或者多个被破损的字符图像，一个字符图形可能通过以下几种途径被破损：</FONT></DIV>
      <DIV><FONT size=4>至多有一行被复制(复制的行紧接其后) </FONT></DIV>
      <DIV><FONT size=4>至多有一行丢失 </FONT></DIV>
      <DIV><FONT size=4>有些"0"可能变成"1" </FONT></DIV>
      <DIV><FONT size=4>有些"1"可能变成"0" </FONT></DIV>
      <DIV><FONT 
      size=4>字符图像不会同时有一行被复制而同时又丢失一行，在测试数据中，任何一个字符图像弄反"0"和"1"的比例不超过30%。</FONT></DIV>
      <DIV><FONT size=4>在行被复制的情况中，复制行和被复制行都可能破损，但破损的情形可能是不同的。</FONT></DIV>
      <DIV><FONT size=4>任务</FONT></DIV>
      <DIV><FONT size=4>用FONT.DAT提供的字体对IMAGE.DAT文件中的一个或者多个字符序列进行识别。</FONT></DIV>
      <DIV><FONT 
      size=4>在一种自己最满意的有关"行"被复制或丢失的假设下，根据实际字符图像和标准字符图像的比较，以"0"和"1"发生错误的总数越少越好为条件来识别给定的字符图像，题中所给的样例字符图像都会被一个好的程序所识别，对于一个被测数据组，有一个唯一的最佳解。</FONT></DIV>
      <DIV><FONT size=4>正确解应该准确使用由输入文件IMAGE.DAT所提供的所有行数。</FONT></DIV>
      <DIV><FONT size=4>输入</FONT></DIV>
      <DIV><FONT size=4>两个输入文件都由整数N(19≤N≤1200)开始，该整数指出下面的行数。</FONT></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4>N</FONT></DIV>
      <DIV><FONT size=4>(digit1)(digit2)(digit3) … (digit20)</FONT></DIV>
      <DIV><FONT size=4>(digit1)(digit2)(digit3) … (digit20)</FONT></DIV>
      <DIV><FONT size=4>…</FONT></DIV>
      <DIV><FONT size=4>每一行的数据都有20个码，码和码之间没有空格。</FONT></DIV>
      <DIV><FONT 
      size=4>文件FONT.DAT描述字体。FONT.DAT总是包含541行。每次FONT.DAT都可能是不同的。</FONT></DIV>
      <DIV><FONT size=4>输出</FONT></DIV>
      <DIV><FONT 
      size=4>你的程序必须生成一个IMAGE.OUT文件。它应该包含一串识别出的字符。它的格式是一行ASCII码。输出结果不应含有任何分隔符，如果你的程序识别不出一个字符，则在相应的位置显示"?"。</FONT></DIV>
      <DIV><FONT size=4>警告：上述输出格式不遵守在规则中规定的在输出的结果中留出空格的规定。</FONT></DIV>
      <DIV><FONT size=4>计分：根据正确识别出的字符的比例确定所得分数。</FONT></DIV>
      <DIV>
      <TABLE cellSpacing=0 cellPadding=0 border=0>
        <TBODY>
        <TR>
          <TD vAlign=top width=190>
            <DIV><FONT size=4>Incomplete sample showing the <I>beginning</I> of 
            FONT.DAT (space and 'a').&nbsp;</FONT></DIV></TD>
          <TD vAlign=top width=190>
            <DIV><FONT size=4>Sample IMAGE.DAT, showing an 'a' 
            corrupted&nbsp;</FONT></DIV></TD></TR>
        <TR>
          <TD>
            <DIV><FONT size=4><TT><B><FONT 
            face=新宋体>FONT.DAT</FONT></B></TT>&nbsp;</FONT></DIV></TD>
          <TD>
            <DIV><FONT size=4><TT><B><FONT 
            face=新宋体>IMAGE.DAT</FONT></B></TT>&nbsp;</FONT></DIV></TD></TR>
        <TR>
          <TD vAlign=top>
            <DIV><FONT size=4>540</FONT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000011100000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000111111011000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001111111001100000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001110001100100000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001100001100010000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001100000100010000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000100000100010000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000010000000110000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000001000001110000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001111111111110000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001111111111110000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001111111111000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV></TD>
          <TD vAlign=top>
            <DIV><FONT size=4>19&nbsp;</FONT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000011100000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00100111011011000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001111111001100000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001110001100100000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001100001100010000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001100000100010000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000100000100010000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000010000000110000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001111011111110000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001111111111110000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001111111111000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00001000010000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000001000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV>
            <DIV><TT><B><FONT face=新宋体 
            size=4>00000000000000000000&nbsp;</FONT></B></TT></DIV></TD></TR>
        <TR>
          <TD>
            <DIV><B><FONT size=4>Figure 1a</FONT></B></DIV></TD>
          <TD>
            <DIV><B><FONT size=4>Figure 
      1b</FONT></B></DIV></TD></TR></TBODY></TABLE></DIV>
      <DIV>
      <DIV><FONT size=4>示例输出</FONT></DIV>
      <TABLE cellSpacing=0 cellPadding=0 border=0>
        <TBODY>
        <TR>
          <TD width=103>
            <DIV><B><FONT size=4>IMAGE.OUT</FONT></B></DIV></TD>
          <TD width=237>
            <DIV><FONT size=4><B>Explanation</B>&nbsp;</FONT></DIV></TD></TR>
        <TR>
          <TD width=103>
            <DIV><FONT size=4>a</FONT></DIV></TD>
          <TD width=237>
            <DIV><FONT size=4>Recognised the single character 
            'a'&nbsp;</FONT></DIV></TD></TR></TBODY></TABLE>
      <DIV><FONT size=4>参考解答 </FONT></DIV>
      <DIV><FONT size=4>此题要使用两次动态规划。具体解法暂缺。</FONT></DIV>
      <DIV><FONT size=4>可以参考来煜坤的论文</FONT><A 
      href="http://algorithm.diy.myrice.com/resources/technical_artile/thesis_form_ioi/thesis99_laiyukun.zip"><FONT 
      size=4><FONT face=宋体><I>把握本质，灵活运用――</I><I>动态规划的深入探讨</I> (Zipped MS Word 
      Document 57KB) </FONT></FONT></A></DIV>
      <DIV><FONT size=4>此题与</FONT><A 
      href="http://algorithm.diy.myrice.com/problems/problem_set/hpc/problem.htm"><FONT 
      face=宋体 size=4>高性能计算机</FONT></A><FONT size=4>的解法类似，请参考该题的解法。</FONT></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4><B>九、动态规划的技巧――阶段的划分和状态的表示</B><B></B></FONT></DIV>
      <DIV><FONT 
      size=4>在动态规划的设计过程中，阶段的划分和状态的表示是非常重要的两步，这两步会直接影响该问题的计算复杂性，有时候阶段划分或状态表示的不合理还会使得动态规划法不适用。</FONT></DIV>
      <DIV><FONT size=4><B>[</B><B>例</B><B>9]</B></FONT><A name=examp7></A><FONT 
      size=4> 街道问题</FONT></DIV>
      <DIV><FONT size=4>在下图中找出从左下角到右上角的最短路径，每步只能向右方或上方走。</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435985.htm" 
      border=0></FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435479.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4><B>[</B><B>例</B><B>10] LITTLE SHOP OF FLOWERS 
      </B><B>（</B><B>IOI’99</B><B>）</B></FONT></DIV>
      <DIV><FONT size=4><B>PROBLEM</B> </FONT></DIV>
      <DIV><FONT size=4>You want to arrange the window of your flower shop in a 
      most pleasant way. You have <I>F </I>bunches of flowers, each being of a 
      different kind, and at least as many vases ordered in a row. The vases are 
      glued onto the shelf and are numbered consecutively 1 through <I>V</I>, 
      where <I>V</I> is the number of vases, from left to right so that the vase 
      1 is the leftmost, and the vase <I>V</I> is the rightmost vase. The 
      bunches are moveable and are uniquely identified by integers between 1 and 
      <I>F</I>. These id-numbers have a significance: They determine the 
      required order of appearance of the flower bunches in the row of vases so 
      that the bunch <I>i</I> must be in a vase to the left of the vase 
      containing bunch <I>j</I> whenever <I>i</I> &lt; <I>j</I>. Suppose, for 
      example, you have a bunch of azaleas (id-number=1), a bunch of begonias 
      (id-number=2) and a bunch of carnations (id-number=3). Now, all the 
      bunches must be put into the vases keeping their id-numbers in order. The 
      bunch of azaleas must be in a vase to the left of begonias, and the bunch 
      of begonias must be in a vase to the left of carnations. If there are more 
      vases than bunches of flowers then the excess will be left empty. A vase 
      can hold only one bunch of flowers.</FONT></DIV>
      <DIV><FONT size=4>Each vase has a distinct characteristic (just like 
      flowers do). Hence, putting a bunch of flowers in a vase results in a 
      certain aesthetic value, expressed by an integer. The aesthetic values are 
      presented in a table as shown below. Leaving a vase empty has an aesthetic 
      value of 0.</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435238.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>According to the table, azaleas, for example, would look 
      great in vase 2, but they would look awful in vase 4.</FONT></DIV>
      <DIV><FONT size=4>To achieve the most pleasant effect you have to maximize 
      the sum of aesthetic values for the arrangement while keeping the required 
      ordering of the flowers. If more than one arrangement has the maximal sum 
      value, any one of them will be acceptable. You have to produce exactly one 
      arrangement.</FONT></DIV>
      <DIV><B><FONT size=4>ASSUMPTIONS</FONT></B></DIV>
      <DIV><FONT size=4>1 &lt;= <I>F</I> &lt;= 100 where <I>F</I> is the number 
      of the bunches of flowers. The bunches are numbered 1 through <I>F</I>. 
      </FONT></DIV>
      <DIV><FONT size=4><I>F</I> &lt;= <I>V</I> &lt;= 100 where <I>V</I> is the 
      number of vases. </FONT></DIV>
      <DIV><FONT size=4>-50 &lt;= <I>A<SUB>ij</SUB> </I>&lt;= 50 where 
      <I>A<SUB>ij </SUB></I>is the aesthetic value obtained by putting the 
      flower bunch <I>i</I> into the vase <I>j</I>. </FONT></DIV>
      <DIV><FONT size=4><B>INPUT</B> </FONT></DIV>
      <DIV><FONT size=4>The input is a text file named <B>flower.inp</B>. 
      </FONT></DIV>
      <DIV><FONT size=4>The first line contains two numbers: <I>F</I>, <I>V</I>. 
      </FONT></DIV>
      <DIV><FONT size=4>The following <I>F</I> lines: Each of these lines 
      contains <I>V</I> integers, so that <I>A<SUB>ij</SUB></I> is given as the 
      <I>j<SUP>th</SUP></I> number on the (<I>i</I>+1)<I><SUP>st</SUP></I> line 
      of the input file. </FONT></DIV>
      <DIV><FONT size=4><B>OUTPUT</B> </FONT></DIV>
      <DIV><FONT size=4>The output must be a text file named <B>flower.out</B> 
      consisting of two lines: </FONT></DIV>
      <DIV><FONT size=4>The first line will contain the sum of aesthetic values 
      for your arrangement. </FONT></DIV>
      <DIV><FONT size=4>The second line must present the arrangement as a list 
      of <I>F</I> numbers, so that the <I>k</I>’th number on this line 
      identifies the vase in which the bunch <I>k</I> is put. </FONT></DIV>
      <DIV><FONT size=4><B>EXAMPLE</B> </FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435719.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4><B>EVALUATION</B> </FONT></DIV>
      <DIV><FONT size=4>Your program will be allowed to run 2 seconds. 
      </FONT></DIV>
      <DIV><FONT size=4>No partial credit can be obtained for a test case. 
      </FONT></DIV>
      <DIV><FONT 
      size=4>本题虽然是IOI’99中较为简单的一题，但其中大有文章可作。说它简单，是因为它有序，因此我们一眼便可看出这题应该用动态规划来解决。但是，如何动态规划呢？如何划分阶段，又如何选择状态呢？</FONT></DIV>
      <DIV><FONT size=4><B>&lt;</B><B>方法</B><B>1&gt;</B></FONT></DIV>
      <DIV><FONT 
      size=4>以花束的编号来划分阶段。在这里，第k阶段布置第k束花，共有F束花，有F+1个阶段，增加第F+1阶段是为了计算的方便；状态变量x<SUB>k</SUB>表示第k束花所在的花瓶。而对于每一个状态x<SUB>k</SUB>，决策u<SUB>k</SUB>就是第k+1束花放置的花瓶号；最优指标函数f<SUB>k</SUB>(x<SUB>k</SUB>)表示从第k束花到第n束花所得到的最大美学值；A(i,j)是花束i插在花瓶j中的美学值,V是花瓶总数,F是花的总数。</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435821.htm" 
      border=0></FONT></DIV>
      <DIV>
      <DIV><FONT size=4>方法1的规划方程中的允许决策空间：x<SUB>k+1</SUB>≤u<SUB>k</SUB>≤V-(F-k)+1 
      比较麻烦，因此有待改进。还是以花束的编号来划分阶段，第k阶段布置第k束花；状态变量x<SUB>k</SUB>表示第k束花所在的花瓶；注意，这里我们考虑倒过来布置花瓶，即从第F束花开始布置到第1束花。于是状态变量u<SUB>k</SUB>表示第k-1束花所在的花瓶；最优指标f<SUB>k</SUB>(x<SUB>k</SUB>)表示从第一束花到第k束花所获得的美学价值；A(i,j)是花束i插在花瓶j中的美学值,V是花瓶总数,F是花的总数。则状态转移方程为：</FONT></DIV>
      <DIV><FONT size=4><IMG 
      src="（第一篇）动态规划 Dynamic Programming.files/20090114141435586.htm"></FONT></DIV>
      <DIV>
      <DIV><FONT 
      size=4>三种不同的方法都成功地解决了问题，只不过因为阶段的划分不同，状态的表示不同，决策的选择有多有少，所以算法的时间复杂度也就不同。</FONT></DIV>
      <DIV><FONT 
      size=4>这个例子具有很大的普遍性。有很多的多阶段决策问题都有着不止一种的阶段划分方法，因而往往就有不止一种的规划方法。有时各种方法所产生的效果是差不多的，但更多的时候，就像我们的例子一样，两种方法会在某个方面有些区别。所以，在用动态规划解题的时候，可以多想一想是否有其它的解法。对于不同的解法，要注意比较，好的算法好在哪里，差一点的算法差在哪里。从各种不同算法的比较中，我们可以更深刻地领会动态规划的构思技巧。</FONT></DIV>
      <DIV><FONT size=4></FONT>&nbsp;</DIV>
      <DIV><FONT size=4>动态规划实现中的问题</FONT></DIV>
      <DIV><FONT 
      size=4>应用动态规划解决问题，在有了基本的思路之后，一般来说，算法实现是比较好考虑的。但有时也会遇到一些问题，而使算法难以实现。动态规划思想设计的算法从整体上来看基本都是按照得出的递推关系式进行递推，这种递推相对于计算机来说，只要设计得当，效率往往是比较高的，这样在时间上溢出的可能性不大，而相反地，动态规划需要很大的空间以存储中间产生的结果，这样可以使包含同一个子问题的所有问题共用一个子问题解，从而体现动态规划的优越性，但这是以牺牲空间为代价的，为了有效地访问已有结果，数据也不易压缩存储，因而空间矛盾是比较突出的。另一方面，动态规划的高时效性往往要通过大的测试数据体现出来（以与搜索作比较），因而，对于大规模的问题如何在基本不影响运行速度的条件下，解决空间溢出的问题，是动态规划解决问题时一个普遍会遇到的问题。</FONT></DIV>
      <DIV><FONT size=4>对于这个问题，可以考虑从以下一些方面去尝试：</FONT></DIV>
      <DIV><FONT 
      size=4>一个思考方向是尽可能少占用空间。如从结点的数据结构上考虑，仅仅存储必不可少的内容，以及数据存储范围上精打细算(按位存储、压缩存储等)。当然这要因问题而异，进行分析。另外，在实现动态规划时，一个我们经常采用的方法是用一个与结点数一样多的数组来存储每一步的决策，这对于倒推求得一种实现最优解的方法是十分方便的，而且处理速度也有一些提高。但是在内存空间紧张的情况下，我们就应该抓住问题的主要矛盾。省去这个存储决策的数组，而改成在从最优解逐级倒推时，再计算一次，选择某个可能达到这个值的上一阶段的状态，直到推出结果为止。这样做，在程序编写上比上一种做法稍微多花一点时间，运行的时效也可能会有一些(但往往很小)的下降，但却换来了很多的空间。因而这种思想在处理某些问题时，是很有意义的。</FONT></DIV>
      <DIV><FONT 
      size=4>但有时，即使采用这样的方法也会发现空间溢出的问题。这时就要分析，这些保留下来的数据是否有必要同时存在于内存之中。因为有很多问题，动态规划递推在处理后面的内容时，前面比较远处的内容实际上是用不着的。对于这类问题，在已经确信不会再被使用的数据上覆盖数据，从而使空间得以重复利用，如果能有效地使用这一手段，对于相当大规模的问题，空间也不至于溢出（为了求出最优方案，保留每一步的决策仍是必要的，这同样需要空间）。</FONT></DIV>
      <DIV><FONT 
      size=4>一般地说，这种方法可以通过两种思路来实现：一种是递推结果仅使用Data1和Data2这样两个数组，每次将Data1作为上一阶段，推得Data2数组，然后，将Data2通过复制覆盖到Data1之上，如此反复，即可推得最终结果。这种做法有一个局限性，就是对于递推与前面若干阶段相关的问题，这种做法就比较麻烦；而且，每递推一级，就需要复制很多的内容，与前面多个阶段相关的问题影响更大。另外一种实现方法是，对于一个可能与前N个阶段相关的问题，建立数组Data[0..N]，其中各项为最近N各阶段的保存数据。这样不采用这种内存节约方式时对于阶段k的访问只要对应成对数组Data中下标为k 
      mod 
      (N+1)的单元的访问就可以了。这种处理方法对于程序修改的代码很少，速度几乎不受影响，而且需要保留不同的阶段数也都能很容易实现。</FONT></DIV>
      <DIV><FONT 
      size=4>当采用以上方法仍无法解决内存问题时，也可以采用对内存的动态申请来使绝大多数情况能有效出解。而且，使用动态内存还有一点好处，就是在重复使用内存而进行交换时，可以只对指针进行交换，而不复制数据，这在实践中也是十分有效的。</FONT></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></CODE>
      <CENTER></CENTER></TD></TR>
  <TR>
    <TD class=Article_tdbgall align=right 
      colSpan=2>文章录入：zy1&nbsp;&nbsp;&nbsp;&nbsp;责任编辑：zy1&nbsp; </TD></TR>
  <TR>
    <TD width=5></TD>
    <TD width=752>
      <LI>上一篇文章： <A class=LinkPrevArticle 
      title="文章标题：在Turbo&nbsp;Pascal系统上编程&#13;&#10;作&nbsp;&nbsp;&nbsp;&nbsp;者：佚名&#13;&#10;更新时间：2009-1-13 10:50:43" 
      href="http://www.ynjy.cn/Article/200901/Article_20090113105043_11911.shtml">在Turbo&nbsp;Pascal系统上编程</A><BR>
      <LI>下一篇文章： 没有了</LI></TD></TR>
  <TR class=Article_tdbgall align=right>
    <TD colSpan=2>【<A 
      href="http://www.ynjy.cn/Article/Comment.asp?ArticleID=14096" 
      target=_blank>发表评论</A>】【<A 
      href="http://www.ynjy.cn/User/User_Favorite.asp?Action=Add&amp;ChannelID=1&amp;InfoID=14096" 
      target=_blank>加入收藏</A>】【<A 
      href="http://www.ynjy.cn/Article/SendMail.asp?ArticleID=14096" 
      target=_blank>告诉好友</A>】【<A 
      href="http://www.ynjy.cn/Article/Print.asp?ArticleID=14096" 
      target=_blank>打印此文</A>】【<A href="javascript:window.close();">关闭窗口</A>】 
  </TD></TR></TBODY></TABLE>
<TABLE class=center_tdbgall style="WIDTH: 760px; HEIGHT: 23px" cellSpacing=0 
cellPadding=0 width=760 align=center border=0>
  <TBODY>
  <TR>
    <TD class=main_shadow></TD></TR></TBODY></TABLE><!--文章显示代码结束--><!--最新热点、最新推荐、相关文章代码开始-->
<TABLE height=60 width=760 align=center>
  <TBODY>
  <TR>
    <TD align=middle>
      <SCRIPT language=javascript 
      src="（第一篇）动态规划 Dynamic Programming.files/26.js"></SCRIPT>
    </TD></TR></TBODY></TABLE>
<TABLE class=center_tdbgall 
style="WIDTH: 760px; WORD-BREAK: break-all; HEIGHT: 129px" cellSpacing=0 
cellPadding=0 width=760 align=center border=0><!--文章底部广告-->
  <TBODY>
  <TR>
    <TD class=main_title_282 width="33%"><B>最新热点</B></TD>
    <TD width=5 rowSpan=2></TD>
    <TD class=main_title_282 width="33%"><B>最新推荐</B></TD>
    <TD width=5 rowSpan=2></TD>
    <TD class=main_title_282 width="33%"><B>相关文章</B></TD></TR>
  <TR>
    <TD class=main_tdbg_760 vAlign=top height=100>
      <SCRIPT language=javascript 
      src="（第一篇）动态规划 Dynamic Programming.files/Article_Hot3.js"></SCRIPT>
    </TD>
    <TD class=main_tdbg_760 vAlign=top width="33%">
      <SCRIPT language=javascript 
      src="（第一篇）动态规划 Dynamic Programming.files/Article_Elite3.js"></SCRIPT>
    </TD>
    <TD class=main_tdbg_760 vAlign=top width="33%">没有相关文章</TD></TR></TBODY></TABLE>
<TABLE class=center_tdbgall style="WIDTH: 760px; HEIGHT: 23px" cellSpacing=0 
cellPadding=0 width=760 align=center border=0>
  <TBODY>
  <TR>
    <TD class=main_shadow></TD></TR></TBODY></TABLE><!--最新热点、最新推荐、相关文章代码结束--><!--网友评论代码开始-->
<TABLE class=center_tdbgall style="WIDTH: 760px; HEIGHT: 23px" cellSpacing=0 
cellPadding=0 width=760 align=center border=0>
  <TBODY>
  <TR>
    <TD class=main_shadow></TD></TR></TBODY></TABLE><!--网友评论代码结束--><!-- ********网页中部代码结束******** --><!-- ********网页底部代码开始******** -->
<TABLE class=Bottom_tdbgall style="WORD-BREAK: break-all" cellSpacing=0 
cellPadding=0 width=760 align=center border=0>
  <TBODY>
  <TR align=middle>
    <TD class=Bottom_Adminlogo colSpan=2>| <A class=Bottom 
      onclick="this.style.behavior='url(#default#homepage)';this.setHomePage('http://www.ynjy.cn');" 
      href="http://www.ynjy.cn/Article/200901/Article_20090114141359_14096.shtml#">设为首页</A> 
      | <A class=Bottom 
      href="javascript:window.external.addFavorite('http://www.ynjy.cn','云南教育门户');">加入收藏</A> 
      | <A class=Bottom href="mailto:">联系站长</A> | <A class=Bottom 
      href="http://www.ynjy.cn/FriendSite/Index.asp" target=_blank>友情链接</A> | <A 
      class=Bottom href="http://www.ynjy.cn/Copyright.asp" 
      target=_blank>版权申明</A> | </TD></TR>
  <TR class=Bottom_Copyright>
    <TD width=180>
      <P align=center><FONT size=4><STRONG>云南省教育厅</STRONG></FONT></P></TD>
    <TD width=580>主办单位：云南省教育厅 | 网站制作维护：云南省教育厅信息中心　地址：昆明市学府路2号教育厅大楼 邮编：650223 
      教育厅业务问询电话：0871-5141240 技术支持电话 0871-5103591 　Copyright　@　2001-2008 
      www.ynjy.cn All Rights Reserved. 　备案序号:滇ICP备05001373号 云教ICP备:200504001 
      红盾网络注册号:033102001111400425 站长：<A href="mailto:"></A> </TD></TR></TBODY></TABLE><!-- ********网页底部代码结束******** --><NOSCRIPT></NOSCRIPT>
<SCRIPT src="（第一篇）动态规划 Dynamic Programming.files/CounterLink.htm"></SCRIPT>
</BODY></HTML>
