动态规划入门24
分类：算法与数据结构 

 例题23

1．能量项链

(energy.pas/c/cpp)

来源NOIP2006（提高组）

【问题描述】

在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为（Mars单位），新产生的珠子的头标记为m，尾标记为n。

需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号表示两颗珠子的聚合操作，(jk)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：

(41)=10*2*3=60。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为

((41)2)3）=10*2*3+10*3*5+10*5*10=710。

 

【输入文件】

输入文件energy.in的第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i<N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

【输出文件】

输出文件energy.out只有一行，是一个正整数E（E≤2.1*109），为一个最优聚合顺序所释放的总能量。

【输入样例】

  4

  2  3  5  10

【输出样例】

710

【问题分析】

 这道题应该算是本次考试的拿分题目，大多选手都做了这道题。可是大多数人都想简单了。其实它就是经典的石子合并的变形。

     （1）标准算法

这道题的考点应该是区间上的动态规划，思考这个问题之前先得解决项链的环状怎么处理。按照题意我们可以枚举切断点，把环状处理成链状。当然更好的方法是把环从任意一点切断，复制成两条链把这两条链首尾向接，针对题的读入我们直接把读入数据复制后连起来即可如：

2 3 5 10      ----------->2 3 5 10 2 3 5 10

          这样处理后其中任意长度为N+1的链就可代表一个环，那么问题就转化成合并任意长度为N+1的链所能释放的总能量最大。

          也就是说从任意一点(i<k<j)把链拆成两段问题的解就是合并这两段释放出最大能量在加上合并后这两颗珠子再一次合并释放的能量。将这个子问题进一步分解就是分解到链长度为1也就是就有两课珠子时，生成这两颗柱子没有释放能量，而合并他们释放的能量是m*r*n。（这就是边界条件）。

           我们设计一个状态opt [i,j] 表示合并头为i，尾为j的链状项链所能释放的最多的能量值。边界条件是opt[i,i]=0 (1<=i<=n*2).

           根据定义不难得到动规的状态转移方程:

             opt[i,j]=max{opt[i,j],opt[i,k]+opt[k,j]+a[i]*a[k]*a[j]}(i<k<j)

       复杂度：

           这个题有2N2个状态，每个状态转移近似为N所以时间复杂度为

       O（N3），由于N很小所以瞬间就可以出解。

  

【源代码】

program energy;

const

 fin='energy.in';

 fout='energy.out';

 maxn=300;

var

 a:array[0..maxn] of longint;

 opt:array[0..maxn,0..maxn] of longint;

 n,ans:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  readln(n);

  for i:=1 to n do

   begin

    read(a[i]);

    a[n+i]:=a[i];

   end;

  close(input);

 end;

function max(x,y:longint):longint;

 begin

  if x>y then exit(x);

  exit(y);

 end;

procedure main;

 var

  i,j,k,L:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  for L:=2 to n do

   for i:=1 to n*2-L+1 do

    begin

     j:=i+L;

     for k:=i+1 to j-1 do

      opt[i,j]:=max(opt[i,j],opt[i,k]+opt[k,j]+a[i]*a[j]*a[k]);

    end;

  for i:=1 to n do

   ans:=max(ans,opt[i,i+n]);

 end;

procedure print;

 begin

  writeln(ans);

  close(output);

 end;

begin

 init;

 main;

 print;

end.
