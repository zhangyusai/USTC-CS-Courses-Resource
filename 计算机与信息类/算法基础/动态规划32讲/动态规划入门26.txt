动态规划入门26
分类：算法与数据结构 

2.6其他问题

   还有一些题目虽和一写基本模型相似但又有区别，我也就不总结共性了，列出它们，看看他们的状态又是怎么设计的：

 

 

 

例题25 



花店橱窗设计

(flower.pas/c/cpp)

来源：IOI或巴蜀评测系统

【问题描述】

    假设以最美观的方式布置花店的橱窗，有F束花，每束花的品种都不一样，同时，至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，并从左到右，从1到V顺序编号，V 是花瓶的数目，编号为1的花瓶在最左边，编号为V的花瓶在最右边，花束可以移动，并且每束花用1到F 的整数惟一标识，标识花束的整数决定了花束在花瓶中列的顺序即如果I < J，则花束I 必须放在花束J左边的花瓶中。
    例如，假设杜鹃花的标识数为1，秋海棠的标识数为2，康乃馨的标识数为3，所有的花束在放人花瓶时必须保持其标识数的顺序，即：杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶中只能放一束花。
每一个花瓶的形状和颜色也不相同，因此，当各个花瓶中放人不同的花束时会产生不同的美学效果，并以美学值(一个整数)来表示，空置花瓶的美学值为0。在上述例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下表格表示。
根据表格，杜鹃花放在花瓶2中，会显得非常好看，但若放在花瓶4中则显得很难看。
    为取得最佳美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。题中数据满足下面条件：1≤F≤100，F≤V≤100，－50≤AIJ≤50，其中AII是花束I摆放在花瓶J中的美学值。输入整数F，V 和矩阵(AIJ)，输出最大美学值和每束花摆放在各个花瓶中的花瓶编号。
┌───┬───┬───┬───┬───┬───┐
│      │花瓶1│花瓶2 │花瓶3│花瓶4 │花瓶5│
├───┼───┼───┼───┼───┼───┤
│杜鹃花│   7  │  23  │ -5    │ -24  │ 16   │
├───┼───┼───┼───┼───┼───┤
│秋海棠│   5  │  21  │ -4   │ 10   │  23  │
├───┼───┼───┼───┼───┼───┤
│康乃馨│  -21 │  5   │  -4   │  -20 │  20  │
└───┴───┴───┴───┴───┴───┘

【输入文件】

    第一行包含两个数：F，V。 随后的F 行中，每行包含V 个整数，Aij 即为输入文件中第（i+1 ）行中的第j 个数

【输出文件】

包含两行:第一行是程序所产生摆放方式的美学值。第二行必须用F 个数表示摆放方式，即该行的第K个数表示花束K所在的花瓶的编号。

【输入样例】

3 5 
7 23 C5 C24 16 
5 21 -4 10 23 
-21 5 -4 -20 20 
【输出样例】

53 
2 4 5 
【题目链接】

http://mail.bashu.cn:8080/JudgeOnline/showproblem?problem_id=1597

【问题分析】

这个问题很奇怪题目中给定的条件是花瓶和花束，似乎是两个没有关联的事物啊，但着两个看似没关联的东西，却有一点联系：不同的花放在不同的花瓶中产生不同的美学价值。

一般人的思维都是拿来花一个一个的放，假设要放第i束花时，把它放到哪里好呢？

很容易想到一个贪心的策略：找到一个符合条件（第i束花要放在前i-1束花的后面）下的它放如后能产生最大的美学价值的花瓶放。但和容易举出反例：

│      │花瓶1│花瓶2 │花瓶3│
├───┼───┼───┼───|
│杜鹃花│   1  │  2   │ -5   |
├───┼───┼───┼─――|
│秋海棠│   5  │  10  │  1  │
按照贪心策略是：杜鹃花放在2号瓶里，秋海棠放在3号瓶里，美学值：3

答案是：        杜鹃花放在1号瓶里，秋海棠放在2号瓶里，美学值：11

数据量很大搜索显然不行。

那要是动态规划，阶段，状态，决策有是什么呢？

既然要拿来花束一个一个的放，我们就以花束划分阶段。设计一个状态opt[i,j]表示将第i束花放在第j个花瓶中可使前i束花或得的最大美学价值，那么决策就很容易想到了：将第i束花放在第j个瓶中，那么第i-1束花只能放在前j-1个瓶里，显然我们要找到一个放在前j-1个瓶中的一个最大的美学价值在加上当前第i束放在第j个瓶中的美学价值就是OPT[I，J]的值。

显然符合最优化原理和无后效性。

状态转移方程：

opt[i,j]=max{opt[i-1,k]}+a[i,j]       (i<=k<=j-1) 为什么是i<=呢？

复杂度：状态数O（FV）*转移代价O（V）=O（FV2）

数据范围很小，可以在瞬间出解。

回顾刚才的解题过程，贪心和动态规划都是找前一阶段的最大值，为什么贪心是错的，而动态规划是对的呢？

着就要读者自己反思，总结了。

【源代码】

program P1597;

const

 maxn=110;

var

 a,opt,path:array[0..maxn,0..maxn] of longint;

 n,m,ans:longint;

procedure init;

 var

  i,j:longint;

 begin

  read(n,m);

  for i:=1 to n do

   for j:=1 to m do

    read(a[i,j]);

 end;

procedure main;

 var

  i,j,k:longint;

 begin

  for i:=1 to n do

   for j:=1 to m do

    opt[i,j]:=-maxlongint;

  for i:=1 to n do

   for j:=i to m-n+i do

    begin

     for k:=i-1 to j-1 do

      if opt[i-1,k]>opt[i,j] then

       begin

        opt[i,j]:=opt[i-1,k];

        path[i,j]:=k;

       end;

     inc(opt[i,j],a[i,j]);

    end;

  ans:=n;

  for i:=n+1 to m do

   if opt[n,i]>opt[n,ans]then ans:=i;

 end;

procedure outputway(i,j:longint);

 begin

  if i>0 then

   begin

    outputway(i-1,path[i,j]);

    write(j,' ');

   end;

 end;

procedure print;

 var

  i:longint;

 begin

  writeln(opt[n,ans]);

  outputway(n,ans);

  writeln;

 end;

begin

 init;

 main;

 print;

end.
