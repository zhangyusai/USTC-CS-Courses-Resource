动态规划入门15
分类：算法与数据结构 

2.状态是二维的

    通过前面的学习，我想因该对动态规划不陌生了，我学习动态规划是没这么系统，二维，一维一起上。二维状态的动态规划是重中之重。

所谓二维状态就是说一般设计的状态是opt[i,j]形式的。那i,j可以代表什么呢？

有很多朋友问过我这个问题，我的回答是：

(1)i,j组合起来代表一个点的坐标（显然是平面坐标系）（如：街道问题）。

(2)i,j组合表示一个矩阵的单元的位置（第i行，第j列）（如：数塔问题）

(3)起点为i长度为j的区间。（如：回文词）

(4)起点为i终点为j的区间。（如：石子合并问题）

(5)两个没关联的事物，事物1的第i个位置，对应事物2的第j个位置（花店橱窗设计）

 (6)两个序列，第一个序列的前i个位置或第i个位置对应第2个序列的第j个位置或前j个位置。（最长公共子序列）。

 (7)其它

 

 

下面通过例题和基本模型进一步说明：

2.1数塔问题

   数塔问题来源于一道经典的IOI的题目，直接说题通过题目总结公性。以后遇到类似的题目可以参照这个模型。

 

 

例题14 

 



数塔问题

                      (numtri.pas/c/cpp)

来源：IOI94

【问题描述】

    考虑在下面被显示的数字金字塔。

写一个程序来计算从最高点开始在底部任意处结束的路径经过数字的和的最大。每一步可以走到左下方的点也可以到达右下方的点。

        7  
      3   8  
    8   1   0  
  2   7   4   4  
4   5   2   6   5  
在上面的样例中,从7 到 3 到 8 到 7 到 5 的路径产生了最大和:30

【输入文件】

    第一个行包含 R(1<= R<=1000) ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

所有的被供应的整数是非负的且不大于100。

【输出文件】

    单独的一行包含那个可能得到的最大的和。

【输入样例】

5 
7 
3 8 
8 1 0 
2 7 4 4 
4 5 2 6 5  
【输出样例】

30

【问题分析】

这个问题是学习动态规划最简单最经典的问题，说它经典是因为它的阶段，状态决策都十分明显。

刚看到题目觉得没有如手点，连怎么储存，描述这个金字塔都是问题，看输入样例发现：数字金字塔可以变成像输入样例那样的下三角，这样可以用一个二维数组储a存它，并且可以用（i,j）描述一个数字在金字塔中的位置。

对于中间的一个点来说，想经过它则必须经过它的上方或左上（针对变化后的三角形）。也就是说经过这个点的数字和最大等于经过上方或左上所得的“最大和”中一个更大的加上这个点中的数字。显然这个定义满足最优子结构。

这样阶段很明显就是金字塔的层，设计一个二维状态opt[i,j]表示走到第i行第j列时经过的数字的最大和。决策就是opt[i-1,j] 或opt[i-1,j-1]中一个更大的加上（i,j）点的数字。

对于一个点只考虑上面或左上即前一阶段，满足无后效性。

状态转移方程：

         opt[i-1,j]+a[i,j]                 (j=1)

opt[i,j]=  opt[i-1,j-1]+ a[i,j]               (j=i)

         max{opt[i-1,j],opt[i-1,j-1]}+ a[i,j]  (1<j<i)

实现时可以将opt[i,j]的左右边界定义的大点，初始opt[i,j]=0

由于在j=1时opt[i-1,j-1]=0,opt[i-1,j]>=0所以方程也可以这样写:

opt[i,j]=max{opt[i-1,j],opt[i-1,j-1]}+a[i,j]

同理　j=i时方程也可以写成上面那样，所以方程综合为：

opt[i,j]=max{opt[i-1,j],opt[i-1,j-1]}+a[i,j]（0<j<=i）

显然答案是走到底后的一个最大值，即：

ans=max{opt[n,i]}           (1<=i<=n)

其实从上往下走和从下往上走结果是一样的，但是如果从下往上走结果就是opt[1,1]省下求最大值了，所以方程进一不改动：

opt[i,j]=max{opt[i+1,j],opt[i+1,j+1]}+a[i,j]（0<j<=i）

复杂度：状态数O（N2）*转移代价O（1）=O（N2）

【源代码】

program numtri;

const

 fin='numtri.in';

 fout='numtri.out';

 maxn=1010;

var

 a,opt:array[0..maxn,0..maxn] of longint;

 n:longint;

procedure init;

 var

  i,j:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(n);

  for i:=1 to n do

   for j:=1 to i do

    read(a[i,j]);

  close(input);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  for i:=n downto 1 do

   for j:=1 to n do

    if opt[i+1,j]>opt[i+1,j+1] then

     opt[i,j]:=opt[i+1,j]+a[i,j]

    else opt[i,j]:=opt[i+1,j+1]+a[i,j];

 end;

procedure print;

 begin

  writeln(opt[1,1]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

